% !TEX TS-program = pdflatex


\documentclass{lncs/llncs}
\usepackage{etex}

\usepackage[T1]{fontenc}
% \usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
%\geometry{a4paper}                   % ... or a4paper or a5paper or ...
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}

%\usepackage{amsfonts}
%\usepackage{fancyhdr}
%\usepackage{cite}
%\usepackage{ifthen}
%\usepackage{amssymb}
%\usepackage{fancyhdr}
%\usepackage{pifont}
\usepackage{stmaryrd}
\usepackage{mathtools,mathpartir}
\usepackage{proof}
%\usepackage{setspace}
\usepackage{enumitem}
\setlist{nolistsep}
%\usepackage{indentfirst}
\usepackage{amsmath,amssymb,amscd,mathrsfs}
% \usepackage{array,booktabs,arydshln,xcolor}
\usepackage{array,booktabs,xcolor}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\usepackage{epsfig,color,enumitem}
\usepackage[%
    font={small,sf},
    labelfont=bf,
    format=hang,    
    format=plain,
    margin=0pt,
    %% width=0.8\textwidth,
    aboveskip=4pt,
    belowskip=-18pt,
]{caption}
\usepackage[list=true]{subcaption}

\usepackage{soul}               % Highlighting: \hl, \so, \ul

\soulregister{\st}{8}
\soulregister\cite7
\soulregister\citep7
\soulregister\secn7
\soulregister\ref7
\soulregister\pageref7
\soulregister{\em}{0}
\soulregister{\bf}{0}
\soulregister{\fig}{7}
\soulregister{\ie}{0}
\soulregister{\etc}{0}
\soulregister{\eg}{0}
\soulregister{\wrt}{0}
\soulregister{\resp}{0}
\soulregister{\cf}{0}
\soulregister{\mdash}{0}
\soulregister{\ndash}{0}

\usepackage[colorinlistoftodos,bordercolor=white]{todonotes}
%% \usepackage[disable,colorinlistoftodos,bordercolor=white]{todonotes}

\newcommand{\noteSB}[2][color=green!40, size=\tiny]{\todo[#1]{{\bf
      Note: } {#2}}}
\newcommand{\noteEM}[2][color=blue!40, size=\tiny]{\todo[#1]{{\bf Eric: } {#2}}}
\newcommand{\noteInSB}[2][inline,color=green!40]{\todo[#1]{{\bf Simon: } {#2}}}
\newcommand{\noteInEM}[2][inline,color=green!40]{\todo[#1]{{\bf Eric: } {#2}}}
\newcommand{\todoMargin}[2][color=red!60, size=\tiny]{\todo[#1]{{\bf
      ToDo: } {#2}}}
\newcommand{\hlEM}[1]{{\sethlcolor{green}\hl{#1}}}

\newcommand{\TODO}[1]{\textcolor{red}{\textbf{[TODO:#1]}}}
%\newcommand{\TODO}[1]{}
\newcommand{\NOTE}[1]{\textcolor{blue}{\textbf{[NOTE:#1]}}}
\newcommand{\ERIC}[1]{\textcolor{blue}{#1}}
\newcommand{\OTvar}{\texttt}
\newcommand{\OTland}{\;\land\ }
\definecolor{airforceblue}{rgb}{0.26, 0.44, 0.56}
\newcommand{\QIN}[1]{\textcolor{airforceblue}{#1}}
\newcommand{\coloncolon}{{:\hspace{-.2ex}:}}
\makeatletter
\newcommand{\raisemath}[1]{\mathpalette{\raisem@th{#1}}}
\newcommand{\raisem@th}[3]{\raisebox{#1}{$#2#3$}}
\makeatother

\usepackage{hyperref}
\usepackage{macrospNets}

\input{XFIG/macros.tex}         % Definitions of macros used in XFig figures

\def\AlgT{\mathcal{T}}
\def\AlgE{\mathcal{E}}
\def\AlgA{\mathcal{A}}
\def\AlgAS{\mathcal{A}_S}
\def\AlgB{\mathcal{B}}
%\def\AlgI{\mathcal{I}}

\newcommand{\mdash}{---}
\newcommand{\ndash}{--}
\newcommand{\cf}[1][\ ]{cf.#1}
\newcommand{\ie}[1][\ ]{i.e.#1}
\newcommand{\etc}[1][\ ]{etc.#1}
\newcommand{\eg}[1][\ ]{e.g.#1}
\newcommand{\wrt}[1][\ ]{w.r.t.#1}
\newcommand{\resp}[1][\ ]{resp.#1}

\newcommand{\goesto}[2][]{\ensuremath{\xrightarrow[#1]{#2}}}
\newcommand{\true}{\ensuremath{\mathit{true}}}
\newcommand{\false}{\ensuremath{\mathit{false}}}

\newcommand{\Pred}{\symb{Pred}}
\newcommand{\MkPred}{\symb{MkPred}}
\newcommand{\Post}{\symb{Post}}
%\usepackage[math]{cellspace}
%\setlength\cellspacetoplimit{ 37pt}
%\setlength\cellspacebottomlimit{18pt}

\pagestyle{plain}

% addition to the mathpartir package for red dotted rules,
% that we use for open-transitions

\makeatletter
\def \dotover {\textcolor{red}{\leavevmode\cleaders\hb@xt@ .22em{\hss $\cdot$\hss}\hfill\kern\z@}}
\def \reddottedrule #1#2{\hbox {\advance \hsize by -0.5em
%\sbox0{$\genfrac{}{}{0pt}{0}{#1}{#2}$} \phantom{\copy0} %
 {\ooalign{\vphantom{$\genfrac{}{}{0pt}{0}{#1}{#2}$}\cr\dotover\cr$\genfrac{}{}{0pt}{0}{#1}{#2}$\cr}}}}

 \def \dottedrule #1#2 {
  {\sbox0{$\genfrac{}{}{0pt}{0}{#1}{#2}$}%
    \vphantom{\copy0}%
    \ooalign{%
      \hidewidth
      $\vcenter{\moveright\nulldelimiterspace
        \hbox to\wd0{%
         \xleaders\hbox{\kern.5pt\vrule height 0.4pt width 1.5pt\kern.5pt}\hfill
          \kern-1.5pt
        }%
      }$
      \hidewidth\cr
    \box0\cr}}
}

\let \defaultfraction \mpr@@fraction
\makeatother

%\newtheorem{theorem}{Theorem}[section]
\newtheorem{prop}[theorem]{Proposition}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{alg}[theorem]{Algorithm}
%\newtheorem{remark}[theorem]{Remark}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{example}[theorem]{Example}
%\newtheorem{problem}[theorem]{Problem}
%\newtheorem{proof}[theorem]{Proof}

% Macros for the SOS rules and proof trees:
%\newcommand\openrule[2]{\redinfer{#1}{#2}}
\newcommand\openrule[2]{\inferrule*[myfraction=\reddottedrule,center]{#1}{#2}}
%\newcommand\openrule[2]{\inferrule*{#1}{#2}}

%% SB: Moved the macro definitions from XFIG/figtex2eps-preamble.tex
%%     to XFIG/macros.tex and added a command to input this latter one
%%     into the paper source (above in this file).
%\newcommand\ostate[1]{\triangleleft{\;#1\;}\triangleright}
%\newcommand\ostate[1]{\triangleleft{#1}\triangleright}

\newcommand{\sm}[1]{\mbox{\boldmath\small #1}}
\usepackage{algorithm} 
%\usepackage{algorithmicx} 
\usepackage{algpseudocode}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\algnewcommand{\IfThen}[2]{\State \algorithmicif\ #1\ \algorithmicthen\ #2}% \IfThenElse{<if>}{<then>}
\algnewcommand{\IfThenElse}[3]{\State \algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse\ #3}% \IfThenElse{<if>}{<then>}{<else>}
%\DeclareMathOperator{\card}{card}
%\DeclareMathOperator{\Flat}{Flat}
\usepackage{listings}
\lstset{basicstyle=\small}
%\usepackage{algorithm} 
%\usepackage{algpseudocode} 


\title{Using SMT engine to generate Symbolic Automata\thanks{This work was partially 
funded by the Associated Team FM4CPS
  between INRIA and ECNU, Shanghai}}
\author{ Xudong Qin\inst{1,2}  \ \ \  Simon Bliudze\inst{3} \ \ \ Eric Madelaine\inst{1}
  \ \ \  Min Zhang\inst{2}} 
\institute{Universit\'e C\^ote d'Azur, Inria, CNRS, I3S, 06902 Sophia Antipolis, France
        \and Shanghai Key Laboratory of Trustworthy Computing, ECNU, China
\and INRIA Lille -- Nord Europe, 40 avenue Halley,
59650 Villeneuve d'Ascq
France}
\date{}                                           % Activate to display a given date or no date

                          % Activate to display a given date or no date


\begin{document}

\maketitle

%\section{}
%\subsection{}


\begin{abstract}
Open pNets are used to model the behaviour of open systems, both
synchronous or asynchronous, expressed in various calculi or
languages. They are endowed with a symbolic operational semantics in
terms of so-called ``Open Automata''. This allows to check properties of
such systems in a compositional manner. 
We implement an algorithm computing this semantics,
building predicates expressing the synchronization conditions
between the events of the pNet sub-systems. Checking such
predicates requires symbolic reasoning over first order logics, but
also over application-specific data. We use the Z3 SMT engine to check
satisfiability of the predicates, and prune the open automaton of its
unsatisfiable transitions.
As an industrial oriented use-case, we use so-called "architectures"
of BIP systems, that have been used to specify the control software of
ESA microsatellites. We use pNets to encode BIP architectures,
extended with explicite data in synchronisations, and we compute their
open automaton semantics. This automaton may then be used to prove
behavioural properties; we give 2 examples, a safety and a liveness
properties of a BIP architecture.
\end{abstract}


\section{Introduction}

In the nineties, several 
works extended the basic behavioural models based on labelled
transition systems to address value-passing or parameterized systems, using
various symbolic encodings of the
transitions~\cite{deSimone85,Larsen87,HennessyLin:TCS95,Linconcur96}. 
In \cite{Linconcur96}, H.M. Lin addressed value-passing calculi, for which he
developed a symbolic behavioural semantics, and proved algebraic properties.
Separately J. Rathke~\cite{HennessyRathke:TCS98} defined another
symbolic semantics for 
a parameterized broadcast calculus, together with strong and weak bisimulation
equivalences, and developed a symbolic model-checker based on a tableau
method for these processes. Thirty years later, no
practical verification approach and no verification platform are
using this kind of approaches to provide proof methods for
value-passing processes or open process expressions. 

Parameterized Networks of Synchronized Automata (pNets) were proposed
to give a behavioural specification formalism for distributed
systems, synchronous, asynchronous, or heterogeneous. They are used in
VerCors, a platform for designing and 
verifying distributed systems, as the intermediate language for various
high-level languages. The high-level languages in VerCors formalize
each component of the distributed system and their composition.
pNets provides the core low-level semantic formalism for VerCors, and
is made of a hierarchical composition of (value-passing) automata,
called parameterized labelled transition systems (pLTS), where each
hierarchical level defines the possible synchronization of the lower levels.
Traditionally, pNets have been used to formalize fully
defined systems or softwares. But we want also to define and reason
about incompletely defined systems, like program skeletons, operators,
or open expressions of process calculi.
The open pNet model addresses this problem, using
"holes" as process parameters, representing \emph{unspecified} subsystems.
The pNet model was developed in a series of
papers~\cite{HMZ:PDP15,henrio:Forte2016} in which many examples have been
introduced showing its ability to encode the operators from some
other algebras or  program skeletons.
The operational semantic of an (open) pNet is defined as an
Open Automaton in which Open Transitions contain logical predicates
expressing the relations between the behaviour of the holes, and the
global behaviour of the system. In the previous publication,
only a sketch of a procedure allowing to compute this semantics was
presented, together with a proof of finiteness of the open automaton, under
reasonable hypotheses on the pNet structure.

Implementing this semantics raised several challenges, in order:
\begin{itemize}
  \item to get a tool that could be applied to pNets representing
    various languages, in particular various actions algebras,
    with their specific decision theories,
  \item to separate clearly the 
      algorithm generating the transitions of the open automaton from
      combination of all possible (symbolic) behaviours, from
      the symbolic reasoning part, specifically here using an SMT
      engine to check the
      satisfiability of the predicates generated by our algorithm,
  \item to build a prototype and validate the approach on our basic
    case-studies, and understand the efficiency of the interaction
    with the SMT solver.
\end{itemize}

In the long goal, we want to be able to check the equivalence between
open systems encoded as pNets. The equivalence between pNets is
"FH-bisimulation" taking the 
predicate of the open transitions into account each time matching such
open transitions. We foresee that the interplay with the SMT solver
that we use here for satisfiability of open transitions will be
similar with what we need to prove (symbolic) equivalence between open
transitions. 

\paragraph{Contribution}
In the article we show how:
\begin{itemize}
\item We define the open automaton generation algorithm, and we
  implemented a full working prototype, within the 
  VerCors platform. In the process, we improved the
  semantics rules from~\cite{henrio:Forte2016}, and add features in
  the algorithm to deal the full 
  model, including management of variables and assignments.
\item We implement the interaction between our algorithm and the Z3
    SMT solver, for checking satisfiability of the transitions
    generated by the algorithm.
\item We show the interest of this approach on an
    industry-inspired case-study, namely one architectural pattern
    extracted from the BIP specification of a nanosatellite on-board
    software.
\end{itemize}





\paragraph{Related work.}

%% \TODO{say that apart from the old work by J. Rathke, we know no other
%%   research addressing our goals, and especially no attempts to develop
%%   an algorithmic treatment of such symbolic systems by interacting
%%   with automatic theorem provers}.

%% \TODO{Then you can list the ATP/ITP you have mentioned Coq, Isabelle,
%%   B-tools, or others like CVC4, as possible alternative to Z3}


%% There is not much research work towards trying 
Very few attempts were made to develop symbolic bisimulation approaches
for the value-passing process algebras and languages\mdash our long-term goals\mdash
especially, there is no algorithmic treatment of the symbolic systems developed by
interacting with automatic theorem provers. The closest work is the
one already mentioned from J. Rathke~\cite{HennessyRathke:TCS98},
who developed the symbolic bisimulation for a
calculus of broadcasting system (CBS). CBS is similar with classic
process calculi such as CCS and CSP, but communicating by broadcasting
values, %one-to-many communication instead of one-to-one communication and
transmitting values without blocking. That makes the definition of
the symbolic semantic and bisimulation equivalence different from the
classic works.


For other applications, such as the analysis of 
programming languages, there exist dedicated platforms using
external automatic theorem 
provers (ATP) or automatic tactics from interactive theorem
provers (ITP), to perform symbolic reasoning, and for example to
discharge some subgoals in the proofs.
Tools like Rodin~\cite{deharbe2013,deharbe2014,abrial2007} have
already integrated several provers, like Z3, as modules for proving
the proof obligations generated from a user model. 
The prover we use, which also happens to be Z3, is developed by Microsoft Research
based on the satisfiability modulo 
theories (SMT), is mainly applied in extended static checking, test case
generation, and predicate abstraction.
In a similar way, there are several ATPs/ITPs we could consider to use for
result pruning and bisimulation checking in our algorithm, as an
alternative to Z3, such as CVC4~\cite{barrett:CAV2011},
Coq~\cite{armand:CPP2011},
Isabelle~\cite{blanchette:FroCoS2011} or others. 


\paragraph{Structure.}
In section
\ref{section:pnets} we give a description and a formal definition of
the pNet model, as found in previous publications. Then in section
\ref{section:examples} we present our use-case, based on a BIP
architecture from the nano-satellite case-study. 
Section \ref{section:op-semantics} recalls briefly the operational semantics
of pNet.
Section \ref{section:implementation} explains in details the algorithm
used to compute this semantics, including the interaction with Z3, and
shows the full result of the semantic computation on the running example.
Finally we conclude and discuss perspectives.
\ref{section:conclusion}. 




\section{Background: pNets definition}
\label{section:pnets}

This section introduces pNets and the notations we will use in
this paper. Then it gives the formal definition of pNet structures,
together with an operational semantics for open pNets.

pNets are tree-like structures, where the leaves are either
\emph{parameterized labelled transition systems (pLTSs)}, expressing the
behaviour of basic processes, or \emph{holes}, used as placeholders
for unknown processes, of which we only specify their set of possible
actions, named \emph{sort}.
Nodes of the tree (pNet nodes) are synchronizing artifacts, using a
set of \emph{synchronization vectors} that express the possible
synchronization between the parameterized actions of a subset of the
sub-trees.


%\smallskip\noindent
\paragraph*{Notations.}
We extensively use indexed structures
over some countable indexed sets, which are equivalent to mappings over
the countable set. % . The indexes will usually be
% integers, bounded or not. Such an indexed family is
%denoted
%follows:
$a_i^{i\in I}$
denotes a family of elements $a_i$ indexed over the
set $I$.
When this is not
ambiguous, we shall use notations for sets, and typically write
``indexed set over I'' when formally we should speak of multisets, and
write $x\in a_i^{i\in I}$ to mean $\exists i\in I.\, x=a_i$.  An empty
family is denoted $\emptyset$. We
denote classically $\overline{a}$ a family when the indexing set is
irrelevant.  $\uplus$ is the disjoint union on indexed sets.

\paragraph*{Term algebra.}
Our models rely on a notion of parameterized actions that are
symbolic expressions using data types and variables. As we want to encode
the low-level behaviour of possibly very different
programming languages, we do not want to impose one specific algebra
for denoting actions, nor any specific communication mechanism. So we
leave unspecified the constructors of the algebra that will allow building
expressions and actions. Moreover, we use a generic {\em action interaction}
mechanism, based on unification between two or more action
expressions. This will be used in the semantics of synchronization
vectors to express various kinds of communication or synchronization mechanisms.

\renewcommand{\P}{\mathcal V}
\def\Talg{\mathcal{T}_{\Sigma,\P}}
Formally, we assume the existence of a term algebra $\Talg$,
where $\Sigma$ is the signature of the data and action constructors,
and $\P$ a set of variables. Within $\Talg$, we distinguish a set of
data expressions $\mathcal{E}_\P$, including a set of Boolean
expressions $\mathcal{B}_{\P}$ ($\mathcal{B}_{\P}\subseteq\mathcal{E}_\P$).
On top of $\mathcal{E}_\P$ we build the action algebra
$\mathcal{A}_\P$, with $\mathcal{A}_P\subseteq\mathcal{T}_\P,
\mathcal{E}_P\cap\mathcal{A}_P=\emptyset$;
naturally action terms will use data expressions as sub-terms.
The function $\vars(t)$ identifies the set of variables in a term
$t\in\AlgT$.

pNets can encode naturally the notion of input actions as found,
\eg in value-passing CCS 
\cite{Milner89} or of usual point-to-point message passing calculi,
but it also allows 
for more general mechanisms, like gate negotiation in Lotos~\cite{LotosISO89}, or broadcast
communications.

\paragraph*{Algebra presentations.}
In practice, the parameterization of the pNet model by some specific
action algebra is realized by the definition of an ``algebra
presentation''. It will be used to check the
well-formedness of a pNet system, and to define the translation of the pNet
semantics into the SMT engine input language.

\def\APres{\mathcal{P}}
\begin{definition}
  An \emph{algebra presentation} is a triple $\APres=\langle\mathit{Sorts},\mathit{Constrs},\mathit{Ops}\rangle$, where

  \begin{itemize}
  \item $Sorts$ is a set of \emph{sorts}
    % \noteSB{Commented out a footnote here\mdash check if still necessary.}
    %% \footnote{Later we may want to extend this with Sort constructors,
    %%   like Array or Pair, but this is not needed now}
  \item $\mathit{Constrs}$ is a set of \emph{constructor operators}: for each $\mathit{Con} \in \mathit{Constrs}$, $arity(Con)=n \in \mathbb{N}$ is its arity 
    and '$Con : (\mathit{sel}_1,\mathit{sort}_1), \dots, (\mathit{sel}_n,\mathit{sort}_n) \rightarrow \mathit{sort}$' is its signature with the associated selectors.
    For each argument, the pair $(\mathit{sel}_i,\mathit{sort}_i)$ defines an auxiliary
    operator of name $\mathit{sel}_i$ with signature $\mathit{sel}_i : \mathit{sort} \rightarrow \mathit{sort}_i$.
    \item $Ops$ is a set of \emph{auxiliary operators}, with their
      arity and signature, of the form: $Op : \mathit{sort}_1, \dots,  \mathit{sort}_n \rightarrow
      \mathit{sort}$
      \item $\mathit{Constrs}(\mathit{sortname})$ and $\mathit{Sels}(\mathit{sortname})$ are, respectively, the sets of
        constructors and selectors of the sort $\mathit{sortname}$
  \end{itemize}
%  \noteSB{I think this can be removed}\hl{All sorts and operator names must be distinct.}
  Constructors of arity 0 are called \emph{constants}, and denoted $\mathit{Consts}(\APres)$.
%  $\mathit{Consts}(\APres) = \{\mathit{Con} \in \mathit{Constrs}\,|\, \mathit{arity}(\mathit{Con})=0\}$.
\end{definition}


Sorts \texttt{Bool} and \texttt{Int} are predefined with standard operators.
Sort \texttt{Action} also, with a constructor \texttt{Synchro} denoting
a synchronized action, i.e. an ``internal'' action that cannot be
further synchronized with the environment. It also comes with an
overloaded \texttt{FUN} constructor, used to build actions with
arguments, that will be instantiated to the required sorts for a given
pNet.

The definition of an Algebra Presentation, and a set of variables
$\P$ fixes the Term algebra elements $\Talg, \AlgB_{\P}, \AlgA_\P$.

\begin{table}[t]\caption{\label{table:BIPalgebra}\leftline{Algebra
      Presentation: predefined Sorts and Operators}}
	\begin{tabular}{p{3cm}p{3cm}p{6cm}}
		\hline\specialrule{0em}{1pt}{1pt}
		Sort & Constructors & Auxiliary Operators
                \\\specialrule{0em}{1pt}{1pt}
		\hline\specialrule{0em}{3pt}{3pt}
		Bool    			&
                $\texttt{true},\ \texttt{false}$&
                $\land,\ \lor,\ \neg,\ \implies,\ =,\ \ne$
                \\\specialrule{0em}{1pt}{1pt} 
                %               		Action 			&  $\texttt{Synchro},\ \texttt{FUN\_Action\_Bool}$ &
                Action 			&  $\texttt{Synchro},\ \texttt{FUN}$ &
                \\\specialrule{0em}{1pt}{1pt}
		Int 				&
                ${0, \{i, -i\}_{i \in \texttt{Nat}}}$  &
                $- \texttt{(unary)},\ +,\ -
                \texttt{(binary)},\ \times,\ \div \text{ \etc}$
%                \\\specialrule{0em}{1pt}{1pt}
%                \textsl{for any sort} & & $=,\ \ne$
		\\\hline\specialrule{0em}{1pt}{1pt}
\multicolumn{3}{l}{\sl Extension for the BIP use-case of Fig.~\ref{schema:ArchFailure:pNet}}
		\\\hline\specialrule{0em}{1pt}{1pt}
                Action & \multicolumn{2}{l} \texttt{FUN\_Action\_Bool}, \texttt{}fail, resume, timeout, reset, start, tick, ask 
		\\\hline
	\end{tabular}
\end{table}

\subsection{The (open) pNets Core Model}
\label{section:pNets}


A pLTS is a labelled transition system with variables, which can be
manipulated, defined, or accessed inside states, actions, guards, and
assignments. 
%
%Without loss of generality and to simplify the formalization, we suppose 
%here that variables are local to 
%state: each state has its set of variables disjoint from the others. Transmitting 
%variable values from one state to the other can be done by explicit assignment. 
%
Each state has its set of variables called \emph{state variables}, 
which can only be modified by the assignment in transitions targeting this state. 
A global state variable of a pLTS is a variable $x$ satisfying
$\forall s\!\in\! S .\, x\!\in\! \vars(s)$. 
%
%Similarly, to simplify the management of variables and without loss of expressivity, we 
%suppose that transitions looping to the same state does not do assignments.
Note that we make no assumptions on finiteness of the set of states, nor
on finite branching of the transition relation.

We first define the set of actions a pLTS can use.  Let $a$
range over action labels, $\symb{op}$ are operators, and $x_i$ range over
variable names. Action terms are:
\[
\begin{array}[l]{rcl@{\quad}p{5.5cm}}
  \alpha\in\AlgA&::=&a(p_1,\ldots,p_n)&\text{action terms}\\
  p_i&::=& ~\symb{Expr}&\text{parameters}\\
  \symb{Expr}&::=& \symb{Value}~|~x~|~\symb{op}(\symb{Expr}_1,\dots,\symb{Expr}_n)&\text{expressions}
\end{array}
\]
%\[
%\begin{array}[l]{rcl@{\quad}p{5.5cm}}
%  \alpha\in\AlgA&::=&a(p_1,\ldots,p_n)&\text{action terms}\\
%  p_i&::=& ?x~|~\symb{Expr}&\text{parameters (input variable or expression)}\\
%  \symb{Expr}&::=& \symb{Value}~|~x~|~\symb{op}(\symb{Expr}_1,..,\symb{Expr}_n)&\text{Expressions}
%\end{array}
%\]

\begin{definition}[pLTS]
\label{pLTS}
%\noteSB{It's a bit strange that algebra presentations are not referred to here}
Given a term algebra $\Talg$, a pLTS is a tuple
$pLTS\triangleq\mylangle S,s_0, \to\myrangle$ where:
\begin{itemize}
\item[$\bullet$]
$S$ is a set of \emph{states}, with $s_0 \in S$ the \emph{initial state}.
\item[$\bullet$] $\to \subseteq S \times L \times S$ is the \emph{transition relation}, with
$L$ the set of labels of the form
$\langle \alpha,~e_b,~(x_j\!:= {e}_j)^{j\in J}\rangle$,
  where $\alpha \in\AlgA_{\P}$ is a parameterized action,
    $e_b \in \AlgB_{\P}$ is a guard, and
    expressions  $\AlgE_{\P}\cup\AlgA_{P}$ are assigned to $x_j$.
If 
$s \xrightarrow{\langle \alpha,~e_b,~(x_j\!:= {e}_j)^{j\in
		J}\rangle} s'\in \to $ then 
                $\vars(e_b)\!\subseteq\! \vars(s)\cup\vars(\alpha)$, and
		$\forall j\!\in\! J .\,\vars(e_j)\!\subseteq\! \vars(s)\land 
x_j\!\in\!\vars(s')$.
%\item[$\bullet$]
%The $x_j$ are \emph{state variables} of %% the state $s'$. 
\end{itemize}
\end{definition}

Now, we define
pNet nodes as constructors for hierarchical behavioural structures.
A pNet node has a set of sub-pNets that can be either pNets or pLTSs, and a
set of \emph{holes}, playing the role of process parameters.

A composite pNet consists of a set of sub-pNets, each exposing
a set of actions. %% , each of them triggering internal actions in each of
%% the sub-pNets.
The relation between actions of a pNet and those of its sub-pNets
%% internal actions is
are given by  \emph{synchronization vectors}, which %% : a
%% synchronization vector 
synchronize one or several internal actions, and
expose a single resulting global action.


\begin{definition}[pNets]\label{def-pnets}
A pNet is a hierarchical structure, whereof the leaves are pLTSs and holes:
$\pNet::= pLTS~|~\mylangle \pNet_i^{i\in I}, S_j^{j\in J}, \symb{SV}_k^{k\in K}\myrangle$,
where
\begin{itemize}
\item[$\bullet$] %\noteEM{Pire que ca, $\I$ n'est pas
                 %defini...}\noteSB{Why is one $\I$ and the other
  %$\I_\P$?}
  $I$ and $J$ are the sets over which are indexed sub-pNets and holes, respectively, such that: $I\cap J=\emptyset$ and  $I\cup J\neq\emptyset$.

\item[$\bullet$] $\pNet_i^{i\in I}$ is a family of sub-pNets.

\item[$\bullet$] $S_j \subseteq \AlgA$ is a set of action terms,
  denoting the $\Sort$\footnote{The definition of $Sorts$ (the
    set of actions of a Hole  
  or pNet), and also of $Leaves$ and $Holes$ (respectively all pLTSs
  and all holes in a pNet), can be found in \cite{henrio:Forte2016}.}
  of hole $j$. 

\item[$\bullet$] $\symb{SV}_k^{k\in K}$, with $K\in\I_\P$, is a set of
  synchronization vectors: for each $k\!\in\! K$,
  $\symb{SV}_k\!=\!\alpha_{l}^{l\in I_k \uplus J_k}\to\alpha'_k$ where
  $\alpha'_k\in \mathcal{A}_\P$, $I_k\subseteq I$, $J_k\subseteq J$,
  $\forall i\!\in\! I_k.\,\alpha_{i}\!\in\!\Sort(\pNet_i)$
%  \noteSB{What is the sort of a pNet? Should we define $\Sort(\pNet)
%    \triangleq \{\Label(\symb{SV}_k\,|\,k \in K\}$?}
  , 
  $\forall j\!\in\!
  J_k.\,\alpha_{j}\!\in\!S_j$, and $\vars(\alpha'_k)\subseteq \bigcup_{l\in I_k\uplus 
  J_k}{\vars({\alpha_l})}$. The global action of a vector $\symb{SV}_k$ is
$\Label(\symb{SV}_k) = \alpha'_k$.


\end{itemize}
\end{definition}

In Fig.~\ref{schema:ArchFailure:pNet}, we show examples of these
constructs, with two pLTSs, one hole and one pNet node encoding our running example.



\section{Running example}
\label{section:FailureTimerMax}
\label{section:BIParchitectures}
\label{section:examples}

As a running example we use the Failure Monitor architecture from the
CubETH nanosatellite on-board software
case-study~\cite{CubETH-case-study} realised using BIP.  BIP
(Behaviour-Interaction-Priority)~\cite{bip} is a framework for the
component-based design of concurrent software and systems.  In
particular, the BIP tool-set comprises compilers for generating C/C++
code, executable by linking with one of the dedicated engines, which
implement the BIP operational semantics~\cite{BarBliu15-offer-scico}.  This
approach ensures that any property, shown to hold on a given BIP
model, will also hold by construction on the generated code.

In this context, the notion of \emph{architecture} was proposed
in~\cite{AttieBBJS16-architectures-faoc} as a mechanism for ensuring
correctness by construction during the design of BIP models.
Architectures can be viewed as operators transforming BIP models.
They formalise design patterns, which enforce global properties
characterising the coordination among the components of the system.
The architecture-based design process in BIP takes as input a set of
components providing basic functionality of the system and a set of
temporal properties that must be enforced in the final system.  For
each property, a corresponding architecture is identified\,\footnote{%
%
  The current approach relies on taxonomies of predefined
  architectures.  Future work may include automatic synthesis of
  architectures from, \eg CTL~\cite{BaierKatoen2008} formulae.
%
} and applied to the model, thereby potentially introducing additional
coordinator components and modifying the connectors that define
synchronisation patterns among ports of components.
In~\cite{AttieBBJS16-architectures-faoc}, it was shown that
application of architectures is compositional \wrt safety properties,
\ie when several architectures are applied, each enforcing a safety
property, the resulting system satisfies their conjunction.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\columnwidth]{XFIG/BIPspec-ArchFailureTimerMax-v2}
  \caption{The BIP specification of the Failure Monitor architecture}
  \label{schema:ArchFailure:BIP}
\end{figure}

Figure~\ref{schema:ArchFailure:BIP} shows a refined version of the
Failure Monitor architecture used in~\cite{CubETH-case-study}.
Contrary to standard BIP models, architectures comprise one or several
\emph{operand} components, whereof only the set of \emph{ports} is
given.  Here, the operand component is $\NameOprnd$ and its interface
consists of the ports $\PortFinish$, $\PortResume$ and $\PortFail$.
The two \emph{coordinator} components\mdash $\NameCtrl$ and
$\NameTimer$\mdash are standard BIP components insofar as they also
have their \emph{behaviour} specified by finite automata extended with
local data variables.  Transitions of these automata are labelled with
the ports of the corresponding components, Boolean guards and update
functions on local variables.  For instance the loop transition
$\tstate{1} \goesto{\PortTick, \GuardTick[], \TimerUpd[]} \tstate{1}$
in the $\NameTimer$ component is labeled by the port $\PortTick$, it
can be fired only when the current value of the local variable $t$ is
greater than $0$.  Upon firing, this transition decrements the value
of $t$ by $1$.  When omitted, the default guard (\resp update
function) is the constant predicate $\true$ (\resp the $\mathit{skip}$
operator).  The constant $\mathrm{Max}$, in $\tstate{0}
\goesto{\PortStart, \TimerInit[]} \tstate{1}$, is a parameter of the
architecture.

Connectors are hierarchical, tree-like structures with component ports
at the leaves.  They define sets of \emph{interactions}, based on the
attributes of the connected ports~\cite{BliSif08-acp-tc}, which may be
either \emph{trigger} (triangles in Fig.~\ref{schema:ArchFailure:BIP})
or \emph{synchron} (bullets in Fig.~\ref{schema:ArchFailure:BIP}).
%
If all sub-connectors of a connector are synchrons, then an
interaction may be executed by the connector only if each subconnector
can contribute.
%
If at least one of the sub-connectors is a trigger, then any
interaction consisting of contributions of any set of sub-connectors,
\emph{involving at least one of the triggers}, can be executed.
%
For instance, the two ports $\NameTimer.\PortStart$ and
$\NameCtrl.\PortFail$ are always synchronised, since they belong to
the same binary sub-connector, where they are both synchrons.  In
particular, this means that whenever the transition $\cstate{0}
\goesto{\PortFail} \cstate{1}$ is fired, so is the transition
$\tstate{0} \goesto{\PortStart, \TimerInit[]} \tstate{1}$,
initialising the timer.  The binary connector $\NameTimer.\PortStart
\bullet\!\!\!-\!\!\!-\!\!\!\bullet \NameCtrl.\PortFail$ is a
sub-connector of a hierarchical connector, where the port
$\NameOprnd.\PortFail$ is a trigger.  Thus, the above interaction can
only happen together with $\NameOprnd.\PortFail$, forming a
ternary interaction.  On the contrary, being a trigger, the port
$\NameOprnd.\PortFail$ can fire alone, forming a singleton
interaction.  The composition semantics of BIP systems consists in
firing exactly one interaction, enabled through at least one of the
top-level connectors, at each execution round.

Finally, \emph{priorities}\mdash defined by a strict partial order on
the set of possible interactions\mdash narrow the choice among the
enabled interactions at any given round.  The default priority is the
so-called \emph{maximal progress}, whereby among any two interactions
$a \subset b$ (as sets of ports), $b$ has higher priority than $a$.
For example, the port $\NameOprnd.\PortFail$ will never fire alone in
a global state, where both $\NameTimer.\PortStart$ and
$\NameCtrl.\PortFail$ are enabled.
%
%% Adding priorities $\NameOprnd.\PortFinish < \NameCtrl.\PortReset$ and
%% $\NameOprnd.\PortFinish < \NameOprnd.\PortResume$, ensures that, after
%% a failure, the operation performed by $\NameOprnd$ cannot finish
%% unless it is explicitly resumed or the system is reset.


Application of the Failure Monitor architecture ensures that, whenever
a failure is registered in the operand component, the system will be
reset, unless a resumption is registered within $\mathrm{Max}$ time
units (more details in Sect.~\ref{section:resultOA}).

\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\columnwidth]{XFIG/FailureTimerPNET}
  \caption{pNet encoding of the Failure Monitor architecture}
  \label{schema:ArchFailure:pNet}
\end{figure}

Figure~\ref{schema:ArchFailure:pNet} shows a pNet encoding of the
above Failure Monitor architecture.  This encoding is structural: each
coordinator component is encoded as a pLTS, the operand
component\mdash as a hole; connectors of the BIP model are encoded as
synchronisation vectors.  Each connector that does not involve
triggers is trivially encoded by a synchronisation vector comprising
the same ports.  In order to encode the semantics of the connectors
involving triggers, we 1)~in the pLTS encoding the coordinator
components, add loop transitions to ensure that all ports involved in
such connectors are enabled in all states, 2)~associate a Boolean
value to each of these ports: the original transitions carry the value
$\true$ (\eg $\cstate{0} \goesto{\PortFail(\true)} \cstate{1}$), the
added loops carry the value $\false$ (\eg $\cstate{2}
\goesto{\PortFail(\false)} \cstate{2}$), 3)~add to the corresponding
synchronisation vectors the Boolean predicate encoding the connector
structure.  For example, $SV0$ encodes the connector discussed above:
the predicate $(b1=b2) \land (b1\lor b2 \Rightarrow b0)$ means that the
``true'' transitions $\NameCtrl.\PortFail$ and $\NameTimer.\PortStart$
can only fire together ($b1 = b2$) and whenever one of them fires,
$\NameOprnd.\PortFail$ must fire also ($b1 \lor b2 \Rightarrow b0$).
This encoding can be systematically obtained for any hierarchical BIP
connector~\cite{BliSif10-causal-fmsd}.
%
Although, for the sake of brevity, we omit priorities from the
encoding, this can be easily achieved, by introducing additional
Boolean variables for relevant ports~\cite{BarBliu15-offer-scico}.

%% Several publications \cite{HMZ:PDP15,henrio:Forte2016} already have introduced
%% many examples of pNets, encoding
%% operators of various classical process algebras, or more complex
%% synchronization structures in distributed or parallel languages.

%% \TODO{1.5 page including figures ?}

%% \TODO{Simon: can you do this in less than one page ? If you prefer,
%%   merge with ``Running example'' may be easier to describe the syntax}

%% \TODO{Simon: or may be better, present BIP architectures and the use-case \_BEFORE\_ The pNets definition, and define the encoding here}

%% \TODO{Should have here both the original BIP drawing (Simon), and the
%%   pNet encoding (fig by Eric)}




\section{Operational Semantics for Open pNets}
\label{section:op-semantics}

The semantics of open pNets will be defined as an open automaton, that
is an automaton where each transition composes transitions 
of several
% \noteSB{These should all be pLTSs, right? Or did I miss
%  something?}\noteEM{Hum, nor really, something intermediate; the actions there can be
%  parameterised actions, but the label has no guard and no
%  assignments}
LTSs with the actions of some holes; the transition occurs if some predicates hold,
and can involve a set of state modifications. Each state of an open
automaton has a set of \emph{state variables} that can be assigned by
incoming transitions. Strictly speaking, the LTSs at the leaves of the
open automaton are a restricted form of pLTSs, where labels are
parametrised actions, but include no guard nor assignments.

\begin{definition}[Open transitions]
	\label{def:OpenTransitions}
	An \emph{open transition} over a set  $\langle S_i,s_{0 i}, \rightarrow_i\rangle^{i\in
	I}$ of LTSs, a
	set $J$ of holes with sorts $Sort_j^{j\in J}$, and a set of states $\mathcal{S}$ is a structure of the form:	
	\begin{mathpar}
	\inferrule*[myfraction=\reddottedrule]
	{\{s_i~{\xrightarrow{a_i}}_i ~s_i^{\prime}\}^{i\in I},
		\{\xrightarrow{b_j}_j\}^{j\in J}, \Pred\,, \Post}
	{s \xrightarrow {v}s'}\,,
	\end{mathpar}
	where $s, s'\in\mathcal{S}$ and, for all
        $i\in I$, $s_i{\xrightarrow{a_i}}_i s_i^{\prime}$ is a transition of the
	LTS $\langle S_i,s_{0 i}, \rightarrow_i\rangle$, and $\xrightarrow{b_j}_j$
        is a transition of the hole $j$, for any action $b_j$ in the
        sort $Sort_j$. \Pred\ is a predicate
	over the variables of the terms, labels, and states $s_i$,
        $b_j$, $s$, $v$. \Post\ is a set of equations that  
	hold \emph{after the open transition}, represented as a
        substitution $\{x_k\gets e_k\}^{k\in K}$  
	where $x_k$ are variables of $s'$ and $s'_i$, whereas $e_k$ are
        expressions over the other variables of the open transition.
\end{definition}


\begin{definition}[Open automaton]
	\label{def:open-automaton}
	An \emph{open automaton} is a structure\\ $A =
	\langle \mathit{LTS}_i^{i\in I},J,\mathcal{S},s_0,\mathcal{T}\rangle$ where:
	\begin{itemize}
		\item[$\bullet$]  $I$ and $J$ are  sets of indices,
		\item[$\bullet$]  $LTS_i^{i\in I}$ is a family of LTSs,
		\item[$\bullet$]  $\mathcal{S}$ is a set of states and $s_0 \in \mathcal{S}$ the initial state,
		\item[$\bullet$] $\mathcal{T}$ is a set of open transitions and, for each
		$t\in \mathcal{T}$, there exist $I'$, $J'$ with $I'\subseteq I$, $J'
		\subseteq J$, such that $t$ is an open transition over $LTS_i^{i\in I'}$, $J'$,
		and  $\mathcal{S}$.
		
	\end{itemize}
\end{definition}
	

%
%Then the semantics of a pNet is characterized by a set of {\em open
%transitions}, where the hypotheses on process parameters are
%replaced by 1) transitions of the pLTSs at the leaves, and 2) formal
%hypotheses on the transitions of the holes. A {\em predicate} is used
%to relate the parameters and names appearing in the actions of the
%leaves and the holes involved in the rules, but also appearing in  the resulting action.

% \TODO{Relate to the algorithm, or even move to section 5}
The \emph{states} and the shape of \emph{predicates} in the
transitions
of an open automaton representing the semantics of a pNet
have the following specific structure.

\paragraph{States of open pNets.}\label{def-states}
  A state of an open pNet is a tuple of the
  states of its leaves (in which we denote tuples
  in structured states as $\triangleleft\ldots\triangleright$).
  For any pNet p, let $\overline{\mathit{Leaves}} = \mylangle S_i,{s_i}_0, \to_i\myrangle^{i \in L}$ be the set of pLTS at its leaves,
  then $\mathit{States}(p) = \{\ostate{s_i^{i\in L}}
  |\, \forall i\in L. s_i \in S_i\}$.
A pLTS being its own single leave:
  $\mathit{States}(\mylangle S,s_0, \to\myrangle) = \{\ostate{s}|\, s \in S\}$.
The initial state is defined as:
$\mathit{InitState}(p) = \ostate{{{s_i}_0}^{i\in L}}$.


%% \begin{example} \emph{State of a pNet}
%%   The states of pNet \texttt{EnableCompL} are:
%%   $\triangleleft 00 \triangleright, \triangleleft 10 \triangleright, \triangleleft 11 \triangleright$
%% \end{example}

\paragraph{Predicates.}
Let
$\mylangle\overline{\pNet},\overline{S},\symb{SV}_k^{k\in K} \myrangle$
be a pNet. Consider a synchronization vector $SV_k$, for $k\in K$. We build a
predicate $\MkPred$ relating
the actions of the involved sub-pNets and the resulting actions. This predicate verifies:
\begin{multline*}
  \MkPred(SV_k, a_i^{i\in I}, b_j^{j\in J}, v)\Longleftrightarrow
  %% \begin{array}{l}
  \exists {(a'_i)}^{i\in I},
          {(b'_j)}^{j\in J},v'.\\
          SV_k={(a'_i)}^{i\in I}, {(b'_j)}^{j\in J}\rightarrow v'
          \land
          \forall i\in I.\, a_i=a'_i\land \forall j \in J.\, b_j=b'_j \land v=v'
\end{multline*}

%% \end{array}


%% This definition is not constructive but it is easy to build the
%% predicate constructively by brute-force unification of the sub-pNets
%% actions with the corresponding vector actions, possibly followed by a simplification
%% step. 

\begin{example}[An open transition]
  This transition is generated by application of the vector \texttt{SV0},
  synchronizing the initial actions of pLTSs \texttt{Control} and
  \texttt{Timer} (see Fig.~\ref{schema:ArchFailure:pNet}), with an action of the hole \texttt{B} equal to
  \texttt{fail}. The local variable \texttt{t} of the \texttt{Timer}
  is assigned to its initial value \texttt{Max}.
 A full output of 
the use-case is provided in appendice~\ref{appendix:fullOutput}.

  \label{OT:example-1}
        \begin{mathpar}
	\inferrule*[myfraction=\reddottedrule]
	{\{s0~{\xrightarrow{\mathit{fail}(\true)}} ~s1, t0~{\xrightarrow{\mathit{start}(\true)}} ~t1\}
	  \{\xrightarrow{\mathit{hb}}\}, \mathit{hb}=\mathit{fail}(\true) \land v=\underline{\mathit{fail}}, \{t := \mathit{Max}\}
        }
	{\ostate{s0,t0} \xrightarrow {v} \ostate{s1,t1}}
	\end{mathpar}
\end{example}
%
%The open transition $ot_2$ involves the possible actions from the process $P$ and prefix expression $acc(x);Q$. The hole behaviour, represented by variable $hb_{12}$ must be equal to the exit action $\delta(x)$, and the accept event $acc(x)$ will capture the same value $x$.
%
%The transition in the conclusion of this rule starts in
%state $\ostate{00}$, where both $C_1$ and $C_2$ are in their initial
%states. It ends in a different structured state, because in $ot_2$
%both pLTS conduct transitions, showing that the control has gone from
%processes $P$ to $(acc(x);Q$, consuming actions $\delta(x)$ and
%$acc(x)$. Controller $C_1$ has only one state, but its state variable
%$s_0$ has changed to 1.


\paragraph{Structural Semantic Rules:}
The semantics of pNet in term of open automata has been defined in
\cite{henrio:Forte2016}, in the form of 2 structural rules, one for
pLTSs, one for pNet nodes.  For convenience we include these rules in
App.~\ref{appendix:semRules}. 


\section{Generation of Open Automata}
\label{section:implementation}
In this section we describe the algorithm implementing the pNet
semantics, the interaction with the Z3 SMT solver, and we show the
result on our  example.

%% \noteSB{
%% line 11: Would it not be better to prune unsatisfiable transitions
%% on-the-fly, \ie inside the loop?}
%% \noteEM{Not so easy, it would require a proof... on one side this
%%   would implement reachability on the fly; but there is the question
%%   of collecting the assignments of the state variables, that are used
%%   in the sat check !}
Algorithm~\ref{alg1} starts with an open pNet, and builds its set of open
transitions. Its main loop is a classical residual algorithm: starting
from the initial global state, it picks a state in an unexplored set, and
computes all possible OTs, adding their target states in the
unexplored set, until this set is empty. As the potential set of
global states is finite (see \cite{henrio:Forte2016}), this terminates.

\begin{algorithm}[h]
  \caption{Open Automaton Generation}
  \label{alg1}
\begin{algorithmic}[1]
\Require A pNet $P$ (cannot be a hole)
        %\qquad \hl{\textbackslash\textbackslash~SB: was `` pn ''}
\State Initialize sets $U=\{\mathit{InitState}(P)\}$ and $E=\emptyset$,
for unexplored and explored global states, respectively; $L=\emptyset$ for the resulting OTs;
\While{!$\mathit{isEmpty}(U)$}
	\State Choose $S$ in $U\setminus E$; add $S$ in $E$;
        %\qquad \hl{\textbackslash\textbackslash~SB: was `` Choose $S$ in $U$ ''}
	\State $\mathit{OT} = \mathit{MakeTransitions}(P, S)$;
        \State Store $\mathit{OT}$ in $L$; 
	\For {each $\mathit{OT} \in L$}
        \State Let $T$ be the target global state of $\mathit{OT}$
	\IfThen{($T \not\in U$ \&\& $T \not\in E$)}{Add $T$ into $U$;}
	\EndFor
\EndWhile
\State Prune the unsatisfiable open transitions in $L$ using the SMT solver;
\State \Return $\mathit{OA}=\mathit{Reachable}(\mathit{InitState}(P),L)$;

\end{algorithmic}  
\end{algorithm}

The inside loop (\emph{MakeTransitions} method) applies recursively
the semantic rules following the structure of the pNet.
When applied to a pLTSs at the leaves, we simply take the pLTS transitions of the
corresponding local state and use the semantic rule (see TR1 in
App.~\ref{appendix:semRules}) to build the OT.\footnote{%
%
  We omit detailed presentation of this case for the sake of brevity.
%
}
When applied to a pNet node we use two methods, combining and
matching, to generate the open transitions in a hierarchical manner,
as shown in Alg.~\ref{alg2}. This method directly manages the
holes of the node, so \emph{MakeTransitions} is never called on a hole.

At the root of the pNet, the predicate of each OT is translated
into SMTlib assertions, and checked for satisfiability.
%
The final open automaton is computed as the set of global states,
reachable after pruning the unsatisfiable OTs.
%
%% Unsatisfiable
%% OTs are pruned, and the final open automaton is computed as the set of
%% global states reachable by satisfiable OTs. 

%
%% \noteInSB{Algorithm~\ref{alg2}, as presented below is not
%%   well-defined: when we reach the leaves, a pLTS does not have any
%%   subnets, hence the loop in lines 2--4 is empty and so is the list
%%   $l$. $\mathit{Combining}(l)$ is then called on an empty list...}

%\noteInSB{Line 2: Tr1 and Tr2 are the semantic rules, right?}

%% \noteInSB{Line 6: Nothing in the assignment $\overline{comb} =
%%   \mathit{Combining}(l)$ depends on $sv$.  Hence, this should probably
%%   be done outside of the loop.}

%% \noteSB{Line 7: There are two type mismatches here: $ot$ is an open
%%   transition, whereas $\mathit{Matching}$ is a predicate\mdash one
%%   cannot assign a predicate to an open transition.  Furthermore, in
%%   the definition of $\mathit{Matching}$, below, $C_n$ is an open
%%   transition, whereas $\overline{comb}$ is a {\em set} of open
%%   transitions, so this call does not type either. There is probably
%%   another inner loop over all tuples of OTs in $\overline{comb}$; even
%%   so the open transition has to be defined completely, not just the
%%   predicate\mdash what is the value of $Post$ for the new transition?
%%   Maybe $\mathit{Matching}$ should not be a predicate, but an OT?
%%   Finally, how is $\mathit{hole}$? (I have removed $v$\mdash here and
%%   in the parameters of the definition of the $\mathit{Matching}$
%%   predicate, because the text in the paragraph ``Matching'' says that
%%   $v$ is fresh.)}
%% \noteEM{Done, please check the new version}

%\noteInSB{Line 8: When is $\mathit{Filter}(ot)$ called?}

\begin{algorithm}[h]
\caption{MakeTransitions() \em{for a pNet node}}
  \label{alg2}
\begin{algorithmic}[1]
\Require a pNet node $P$ with subnets $\overline{sn}$ and holes $\overline{hole}$; a global state $S$.
\State Initialize empty list $l$ and set $L$ for sub-transitions and transitions, respectively;
	\For{each $\mathit{Subnet}$ in $\overline{sn}$}
        \hfill $\setminus \setminus$ Recursively apply the semantic rules on the subnets
           \State Store $\mathit{MakeTransitions}(Subnet, S)$ in $l$;
	\EndFor
	\State $\overline{comb} = \mathit{Combining}(l)$;
	\For{ each $sv \in SV$ and each $comb \in \overline{comb}$ }
           \State $ot = \mathit{Matching}(sv, \overline{\mathit{comb}}, \overline{\mathit{hole}})$;
           \IfThen{($ot$ is defined)}{Store $ot$ in $L$; ~~~ $\setminus \setminus$ if $\mathit{Matching}()$ succeeds}
	\EndFor
\State \Return $L$;
\end{algorithmic}  
\end{algorithm}



%
%For holes, their behaviour is unspecified, it doesn't have an exact
%external presentation of action. We only give an action variable to each hole
%and treat it as hole behaviour to suppose working status of the
%hole.
%% Here should have a constraint that this variable belongs to the sort of hole.
%In every case, the hole behaviours are unchanged, so we
%only make the combinations of subnets' open transitions. 
%


\def\inactive{\{-\}}
\paragraph{Combining.}
The combining method enumerates all the possible behaviours of the
subnets as all the possible combinations of their open transitions.
Assume that there is a collection of $n$ subnets.
%% \noteSB{These variables are not used and conflict with the returned
%%   set $L$ in Alg.~\ref{alg2}, on one hand, and control states $s_i$ of
%%   the subnets, on the other.}
%% \st{$L = {s_1, s_2, ...,  s_n}$;}
We denote $\overline{ot}_i$ the set of open
transitions of the $i$-th
subnet (obtained in line~3 of the algorithm); %% $s_i$ and 
``$-$'' means that the subnet is not involved.
The combination $\overline{comb}$, a set of n-tuples, is the
cartesian product:  
$\overline{comb} = (\inactive\cup \overline{ot}_1) \times (\inactive\cup \overline{ot}_2)\times \dots \times (\inactive\cup \overline{ot}_n)$.

%Algorithm 2 shows the combining algorithm for enumerating all possible
%working status combinations from subnets. Dealing with a list $TR$
%containing  sets of open transitions from different subnets,
%the algorithm choses one of sets $L_{ot}$ and does combining on the
%remaining part of $TR$ recursively. The case when a subnet is not working is
%managed by adding a $null$ into the $L_{ot}$.



\paragraph{Matching.}
The \emph{Matching} method builds the OTs of a pNet node from those of
its subnets (see rule Tr2 in App.~\ref{appendix:semRules}).
For each synchronisation vector and each possible
combination of behaviours of the subnets, as generated by the \emph
{Combining} method, it builds the corresponding open transition.
Here, we only detail the construction of the predicate.
From a synchronization vector
$sv = \left((a'_i)^{i\in I} (b'_j)^{j\in J}\rightarrow v'\right) \in SV$
and its guard $G_k$; a tuple of open transitions
$C = ({ot}_i)^{i \in [1,n]} \in \overline{comb}$, such that, for each $i \in [1,n]$, either $ot_i = -$, or the result action of $ot_i$ is $a_i$; the hole behaviours $\mathit{Hole} = (b_j)^{j \in J}$; and a fresh variable $v$, representing the result action of the OT under construction, we build the predicate:
%
\begin{multline*}
  \mathit{MkPred}(sv, C, \overline{\mathit{hole}}) = 
  \\
  (\forall i\in I, a_i=a'_i) \land
  (\forall i \not\in I, ot_i = -) \land
  (\forall j\in J, b_j=b'_j) \land
  (v=v') \land G_k.
\end{multline*}


\paragraph{Filtering.}
While matching a vector with a combination tuple, \emph{Matching}
tries to filter out some incompatibilities; there may be several
reasons why the matching would fail: 
\begin{itemize}
  \item if some subnet is marked as inactive in the vector, and the
    chosen combination has an active behaviour at this position,
  \item if some subnet action expression in the vector does not match (by
    pattern-matching) the corresponding action expression in $C$,
  \item or if the whole set of active subnet actions in the vector
    cannot be matched (by unification) with the corresponding action expressions
      on the tuple $C$.
\end {itemize}

%\st{Each of these possible filters is more precise than the previous
%  ones. But e}
Even when unification succeeds, it is still possible that
the resulting predicate would be unsatisfiable, because of some
incompatibility involving the guards. In our algorithm, we choose to
apply only the simplest filter inside the \emph{Matching} method. All
the rest will be checked later, using the satisfiability check in the
SMT engine.


\subsection{Management of state variable assignments}


In a pLTS, there may be several incoming transitions 
that assign potentially different values to a state variable.
To handle such cases, the algorithm manages, for each pLTS state, a
list of expressions collected from the assignments of each state
variable. %% $v$.
%% The list we used contains triples <$v$, $S$, $AssignRH$> 
%% where $v$ is the variable in pLTS, $S$ is its owner state and
%% $AssignRH$ is a list of expressions over other variables in the right
%% hand side of assignments of $v$.
% As a pragmatic extension to the formal definition, we also manage
% ``global variables'', defined in all states of the pLTS.
For a global state in the open automaton, the set of state
variables (which may be used in a transition) %% will simply be
the union
of sets of state variables of the individual pLTS states constituting this
global state (variables of different pLTS are distinct).
%There are some assignment on the variables in each of states of the pLTS (state variables), or just as global states of it (global variables). There is usually not only one assignment for a state variable, miss of them may drop the unsatisfiable results. In order to avoid such mistakes, 


%% \QIN{
%% The list we used contains several triples <$v$, $S$, $AssignRH$> to
%% record the information of both state and global variables of the pLTS,
%% where $v$ is the variable in pLTS, $S$ is its owner state and
%% $AssignRH$ is a list of expressions over other variables in the right
%% hand side of assignments of $v$. It means the variable is global in
%% the pLTS belonging to all the states, if $S$ is $null$. We update the
%% list of record triples every time Tr1 is applied. Then we can track
%% all the possible (symbolic) value of the variables when computing open transitions.
%% }

\subsection{Pruning the unsatisfiable results}
\label{section:pruning}

\begin{figure}[t]
\begin{mathpar}
    ot = \openrule{\{s0 \xrightarrow{fail(true)} s0, t0 \xrightarrow{resume(false)} t0\}, ~~\{\xrightarrow{hb}\},~~fail(true)=fail(b_1)\\
    \OTland resume(false)=start(b_2)\OTland hb=fail(b_0)\OTland v=\underline{fail}\OTland b_1=b_2\\
    \OTland (b_1\lor b_2) \Rightarrow b_0, ~~\{\}}
    	   {\ostate{s0,t0} \xrightarrow{v} \ostate{s0,t0}}
  \end{mathpar}
\caption{One of the unsatisfiable open transitions in the Failure Monitor pNet}  \label{schema:unsat-ot}
\end{figure}

Our matching/filtering strategy builds some transitions where
the predicates express incompatible constraints. Even if having an
unsatisfiable (symbolic) transition would not be incorrect,
we choose to minimize the open automaton (\ie its number of
transitions and states), by checking the predicates for satisfiability.
In Fig.~\ref{schema:unsat-ot}, we show an 
unsatisfiable open transition 
from the open automaton of our running example. It shows the case where
the failure controller performs a ``$\PortFail$'' action, while the timer
executes a ``$\PortResume$''. The chosen synchronization
vector (SV0 from Fig.~\ref{schema:ArchFailure:pNet}) does not match
with these actions, since it expects $\NameTimer.\PortStart$. This
  mismatch is materialised by the predicate
fragment ``$\mathit{resume}(\false)=\mathit{start}(b_2)$''. 

Checking satisfiability requires some symbolic computation
on the action expressions and the predicates, which
may depend on the specific theory of the action algebra datatypes. 
The ``Modulo Theory'' part of SMT solvers is important here, so that
the solver can use specific properties of each action algebra.


\subsection{Translation to SMTlib}

We check the satisfiability of each open transitions
using the SMT solver Z3. More precisely, we translate
the OT predicate into an SMTlib assertion in the context provided by
the possible state variable assignments in the source state. In this
section, we describe the translation of the algebra presentation, of
assignments, and of the predicates.

Our implementation submits satisfiability requests to
Z3 using its JAVA API. Here, for readability, we
show the Z3 code using its SMT-LIB input language.
Note that in the previous sections, the OTs were displayed in a
  simplied, human readable form. The input and output of our tool, and
  also the generated SMTlib fragments, are
  slightly more difficult to read, in 
particular use structured names for the fresh variables generated
by the algorithm, allowing tracability of the result (see
appendix~\ref{appendix:variables}).

Figure~\ref{schema:smt-lib} shows the translation of the
transition of Fig.~\ref{schema:unsat-ot}
in the SMTlib syntax.
It contains the declaration
of the BIP action algebra sorts 
and constructors, then the declaration of variables, and finally the
predicate to be checked, encoded as a set of assertions.
Here we display also the proof generated by Z3;
%% \noteSB{I am not sure I understand the entire message of this phrase}\hl{though in practice our tool only needs the brute information ``sat''
%% or ``unsat''.
The result "unsat" in the output is just what we expected.
% as appears in the ``unsat'' proof generated by Z3 in which ``\{= ?x66 ?x70\}'' is shown to be false (see Fig. \ref{schema:smt-lib})

\begin{figure}[t]
  %  \centerline{\includegraphics[width=12cm]{XFIG/SMTLIB2}}
    \centerline{\includegraphics[width=\linewidth]{XFIG/SMTLIB3}}
  \caption{The input of the Z3 solver in SMT-LIB language and the output result}  \label{schema:smt-lib}
\end{figure}

%% \begin{figure}[t]
%%   \centerline{\includegraphics[width=10cm]{XFIG/Interaction}}
%%   \caption{The architecture of the interaction between pNet API and Z3}  \label{schema:interaction}
%% \end{figure}

To build the input submitted to Z3 for each OT,
we translate the algebra presentation, the predicates and the
variable assignments (the Post part) into Z3 (Java-API) syntax.
% The $presentation$ and the predicates are translated separately. 

\paragraph{Translation of action algebra presentation.}
In App.~\ref{appendix:mapsmt}, we formally define the condition of
well-formedness of an algebra presentation, and its translation into
SMTlib declarations (\texttt{declare-datatypes} and
\texttt{declare-fun}). It ensures that the generated code is correct,
and will not raise runtime errors in the SMT engine. Remark that the
\texttt{declare-datatypes} command comprises both the action
constructors from table \ref{table:BIPalgebra} and also the constant action
names from our example.


%% \paragraph{Translating assignments into predicate terms.}
%% State variable assignments that were collected during the open
%% automaton are used when generating the SMTlib asserts (see
%% App.~\ref{appendix:translating-assignments}). \noteSB{I am not an expert of Z3 or SMT-LIB, but the clause '\texttt{(= t (- t 1))}' looks very suspicious to me.}\hl{This appears in
%% line 10 of Fig.~\ref{schema:smt-lib}, which encodes possible values of
%% the variable $t$ of the timer.}

%The assignments are also taken into account when checking the
%satisfiability of the open transitions as they represent the value of
%the variables involved in an OT. In order to do that, we employs a
%translation from assignments into term of predicates. The assignments
%required to be translated are only those belong to the variables
%contain in the start states of the open transitions. The assignments
%are represented as equations between the variables and the expressions
%on the right side of assignment. For the assignments of the same
%variable, we do not figure out which state is the precursor of current
%state, we keep all these possible equations instead, and generate the
%disjunction of these equations. The state could always move to the
%target state if there exists one of the values of its variable
%satisfies the guard.
%%\TODO{It won't matter the variable of the next state
%%except that the right hand side expression contain its variables. This
%%is a problem left to be solved in our future work. WHICH PROBLEM ?}
%After that, for the assignments of the different variables, we generate a conjunction of them. This way we obtain a new term of the predicate involving assignments of the variables.

%% State-variable assignments are also treated as a part of the
%% predicates when checking the satisfiability. % Here we need conduct some
%% % translations,
%% For each assignement in a $\Post$ predicate, such as $\{s_0 \leftarrow 1\}$ in section
%% ~\ref{section:op-semantics}, we translate it into an equation
%% $s_0=1$. For several assignments of the same variable in the same state,
%% we generate the disjunction of 
%% these equations. Correspondingly, we generate a conjunction for the
%% assignments from different variables. 


\paragraph{Checking satisfiability.}

In App.~\ref{appendix:mapsmt} we formally define all steps of the translation of each
open transition, including:
%
\begin{itemize}
\item collect all variables in the transition, and declare them,
\item check well-formedness and correct typing of expressions,
\item translate the predicate into a conjunction of assertions,
\item if present in the source state, translate the state-variable
  assignments into a disjunctive assertion.
\end{itemize}
%
Here again, this translation ensures that no runtime error will occur
when running the SMT engine.

Figure~\ref{schema:smt-lib} shows the decomposition of the
predicate into a set of asserts, each encoding an elementary equality,
inequality, or a guard. 
The result (sat or unsat) of the final command in the translation (\texttt{check-sat}) is decoded by
our algorithm.


\subsection{Result for the running example}
\label{section:resultOA}

For this example, the tool builds 184 open transitions, whereof 173
are detected unsatisfiable by Z3.  The resulting open automaton, with
3 reachable global states (out of the possible 6) and 11 open
transitions, is shown in Fig.~\ref{schema:resultOA}.

\begin{figure}[t]
  \centerline{\includegraphics[width=12cm]{XFIG/FailureTimerOA}}
  \caption{Open Automaton for the Failure Monitor architecture}
  \label{schema:resultOA}
\end{figure}

To improve the readability of this figure, we used the following conventions:
we omit the transitions of the two pLTS, and the set of ``working''
holes; and we directly write the resulting action as first element of
each OT, rather than including it as an equality inside the
predicate.
%
Notice, however that the loop transitions
$\underline{\mathit{resume}}$ in states $\ostate{s0,t0}$ and
$\ostate{s2,t0}$, corresponding, respectively, to open transitions
$ot_2$ and $ot_9$ in Fig.~\ref{schema:ots} of
App.~\ref{appendix:fullOutput}, involve $\OTvar{resume(false)}$ from
the two pLTS, \ie only the hole, corresponding to the operand
component of the Failure Monitor architecture, executes $\PortResume$.

Failure Monitor enforces 1)~the safety property \emph{``the
  system reset never happens, unless asked for by a timeout
  following a failure''}, formalised in CTL by
%
\[
\varphi \land \mathtt{AG} (\PortReset \rightarrow \varphi),
\quad\text{where}\
%
\varphi = \mathtt{A} [\lnot \PortReset\ \mathtt{W}\ \PortAsk]
\land \mathtt{A} [\lnot \PortAsk\ \mathtt{W}\ \PortFail],
\]
%
($\mathtt{W}$ being the \emph{weak until} operator) and 2)~the
liveness property \emph{``a reset will be fired when asked for by
  a timeout''}:
%
$\mathtt{AG}(\PortAsk \rightarrow \mathtt{AF}\ \PortReset)$.
%
The satisfaction of the safety property could be established by
applying symbolic model checking techniques.  However, in this
example, it is obvious by inspection of the open automaton.  The
satisfaction of the liveness property relies on the above observation
that in the state $\ostate{s2,t0}$ only the reset transition involves
$\NameCtrl$.  Therefore, under resonable scheduling assumptions,
$\PortReset$ will always be fired.


%% \TODO{it would be good to express here maybe 2 properties of the
%%   architecture, maybe one taken from the original study, and another
%%   one involving the timer data (number of ticks ?)}


\section{Conclusion and Discussion}
\label{section:conclusion}

In this paper, we presented an algorithm for generating an open
automaton representing the semantics of an open pNet.
We have also presented our implementation, which comprises two main
parts.
%\noteEM{doit pouvoir se reecrire de maniere plus simple et concise...}
%\hl{
  Firstly, we
  compute
%}
all the possible open transitions.
The algorithm combines the actions of subnets and
hole behaviors, which are then matched with the
synchronization vectors by the generated
predicate.  Some of the open transitions obtained at this
intermediate step, constructed in a structural manner from all
possible combinations of possible logical predicates, may
contain predicates which do not represent any possible concrete
instantiations. 
Secondly, to get rid of these useless transitions, we use the SMT solver Z3 for checking the
satisfiability of the predicate in each open transition. 
To this end, we encode into Z3 the representations of the action algebra and
the predicates before submitting them to the
Z3 solver. 
%
%\hl{%
%
In this paper, we used a running example, based on a BIP
architecture from an earlier nanosatellite case
study~\cite{CubETH-case-study}.  This example shows that
open-automata-based semantics can be instrumental in verifying the
properties enforced by the architectures through an encoding into open
pNets.  This encoding\mdash which we intend to formalise and prove
correct in a separate paper\mdash also opens the way for an extension
of BIP architectures with the transfer of data among variables of
different components.  Indeed, such data transfer can be easily
encoded using the predicates associated to synchronisation vectors in
open pNets.  The encoding of open transitions into SMTlib and the
availability of theories can guide the definition of such an extension.
%
%}
%
Our case-studies show that our encoding
successfully identifies the unsatisfiable open transitions and that
the resulting automata correctly reflect the expected 
movements of the encoded process expressions.   

%% Among the questions that have arised during this work, an important one is the
%% efficiency of Z3 for our needs. Z3 is famous for being very fast in
%% solving very large sets of assertions. %% , which could be important for
%% %% us
%% However, we encountered problems during the implementation of the
%% checking method. %% using Z3. 
%% For example, if the $\mathit{functions}$ and the
%% $\mathit{datatypes}$ part of the algebra presentation that we submit to the solver
%% are independent from each other, then checking the $\mathit{assertions}$ is 
%% simple. However, $\mathit{functions}$ on recursive $\mathit{datatypes}$ make it
%% more complex. Special rules might be defined by the user for the
%% induction.  We need more evidence that dealing with more complex
%% action algebras, which would involve axiomatizing their data structures
%% as Z3 theories, will allow us to decide validity of
%% predicates.
%% We may also try other automatic theorem provers, depending on the structure of the proofs we need.

%% \todoMargin{Change perspective: we are working on the formal extension of
%%   BIP architectures, and their semantics in terms of pNets. Then
%%   bisimulation and model-checking principles adapted to open pNet
%%   systems are under development}
%
Naturally, our next goals after the generation of the open automata
will be to model-check logical properties, and to check equivalence of pNets. While
model-checking open automata (with a suitable logic including
predicates on data) seems easy to define, equivalence checking is more challenging.
In~\cite{henrio:Forte2016}, we
have already found the FH-bisimulation, inspired by~\cite{deSimone85}, to be a
suitable definition. But weak equivalences, or refinements, will
definitely be useful when comparing different pNets with
different structure. For bisimulation, we foresee that SMT methods
will be the basis for comparison of open transitions. 
%However, the usual approach of computing bisimulation by partition
%% refinement does not work easily with symbolic transitions. In a first
%% step we may want instead to define and implement an algorithm for
%% checking that a given equivalence relation between open automata 
%% states is indeed a FH-Bisimulation. Finding automatically a
%% bisimulation relation or the most general bisimulation will be more
%% challenging.
%% It appears also that when comparing different pNets with
%% different structure, strong bisimulation will be too strong a notion,
%% and that we will have to define proper notions of weak equivalence or
%% refinements. 

\emph{Scaling up.} One important motivation of this work is to
attack the complexity of verification of realistic systems by a
composition and parametric approach. Still one may wonder if the price
for analysing our our symbolic transitions will not make the approach
innaplicable. As a first exercice in this direction, we tried a
slighly bigger example, assembling 2 Failure controlers. We give some
figures from this try in appendix~ref{}, showing that Z3 can check the
satisfiablility of a 90K open transitions in a metter of minutes.


\bibliographystyle{lncs/splncs}

% \bibliography{oasis,biblio}
\bibliography{biblio}

\newpage
\appendix
%\section{Appendix}
The following appendices are included for the convenience of reviewers.
Our intention is to publish as a research report, before final publication, an
extended version containing all technical details, proofs, and more examples.

These are organized in the following way:

\begin{enumerate}
\item[A] pNet semantic rules
\item[B] Variable management
\item[C] Algebra presentations
\item[D] Well-formness and typing of expressions
\item[E] Translation to SMTlib input language
\item[F] Full output for our use-case
  
\end{enumerate}


\section{pNet semantic rules}
\label{appendix:semRules}

\paragraph{Note:} For convenience, we have included here the semantic rules for pNets,
that were already published in \cite{henrio:Forte2016}.

We build the semantics of an open pNet as an open automaton where
LTSs are the pLTSs at 
the pNet leaves, and the states are structured as in
the previous section. 
%given by Definition~\ref{def-states}.
To build an open transition one first
 projects the global state into states of the leaves, then applies
pLTS transitions on these states, and compose them with actions of
holes using synchronisation vectors. %The pNet
%structure does not appear in the open-automaton, only the
%set of Holes and the set of Leaves.

The semantics   regularly instantiates \emph{fresh} variables, and uses a
\emph{clone} operator that clones a term replacing each variable with a
fresh one.
The variables in each synchronization vector are considered local:
for a given pNet expression, we must have fresh local variables for
each occurrence of a vector (= each time we instantiate rule
Tr2). Similarly the state variables of each copy of a
given pLTS in the system, must be distinct, and those created for each
application of Tr2 have to be fresh and all distinct. 

% The semantic of the open pNets is already defined as an open automaton
% in \cite{henrio:Forte2016} using open transitions to present the
% transitions of its global states.

\begin{definition}[Operational semantics of open pNets]
  \label{def:operationalSemantics}
  The semantics of a pNet $p$ is an open automaton $A = <Leaves(p),J,\mathcal{S}, s_0,
  \mathcal{T}>$ where:
  \begin{itemize}
    \item $J$ is the indices of the holes: $Holes(p)= H_j^{j\in J}$.
    %  \item $\overline{L}^L = Leaves(p), \overline{H}^J = Holes(p)$
    \item $\overline{\mathcal{S}} = States(p)$ and $s_0 = InitState(p)$
    \item $\mathcal{T}$ is the smallest set of open transitions
    satisfying the rules below:
  \end{itemize}
  
  The rule ({\bf Tr1}) for a pLTS $p$  checks that the guard 
  is verified and transforms assignments into post-conditions:
  
  \begin{description}
    \item[{\bf Tr1:}]
    $\inferrule
    { s \xrightarrow{\langle \alpha,~e_b,~(x_j\!:= {e}_j)^{j\in
          J}\rangle} s'\in \to  \\
      {\tt fresh}(v) \\
      Pred = ~e_b \land (v = \alpha)
    }
    { p = \mylangle  S,s_0, \to \myrangle
      \models
      \inferrule*[myfraction=\reddottedrule]
      {\{s \xrightarrow{\alpha}_p s'\} ,\emptyset ,
      Pred,\left\{x_j\gets e_j\right\}^{j\in J}}
      {\ostate{s} \xrightarrow{v} \ostate{s'}}
    }
    $
  \end{description}
% Note that this note is greatly simplified by the fact that variables are local to 
% thread; introducing global state variables or accepting loops to the same 
% state would 
% require to reason 
% on the scope of 
% each variables, and to introduce additional variables to handle the several occurence 
% of the same pLTS variable in the predicates. Indeed the constraints on pLTS 
% transitions 
% ensure that the same variable never appears both on the left and on the right of the 
% equations of a predicate.
  
  The second rule ({\bf Tr2}) deals with pNet nodes: for each possible
  synchronization vector applicable to the rule subject, the premisses
  include one {\em open transition} for each sub-pNet involved, one possible
  {\em action} for each Hole involved, and the predicate relating these
  with the resulting action of the vector.
  A key to understand this rule is that the open transitions are
  expressed in terms of the leaves and holes of the pNet structure,
  i.e. a flatten view of the pNet: e.g. $L$ is the index set of the
  Leaves, $L_k$ the index set of the leaves of one subnet, so all $L_k$
  are disjoint subsets of $L$. % Thus the states in the open transitions,
%   at each level, are tuples including states of all the
%   leaves of the pNet, not only those involved in the chosen
%  synchronization vector.
  
  \begin{description}
    \item[{\bf Tr2:}]
  \end{description}
  
  \noindent
    $\inferrule
    {k\!\in\! K \\ SV\!\!= \!clone(SV_k) \!=\! \alpha_m^{m \in I_k\uplus J_k} \!\to\! 
    \alpha'_k, G_k \\
      Leaves(p) \!=\! \pLTS_l^{l\in L} \\     
      \forall m\in I_k.
      \pNet_m \models
      \inferrule*[myfraction=\reddottedrule]
      {\{s_{i}\xrightarrow{a_{i}}_i s_{i}'\}^{i\in I_m^\prime},
      \{\xrightarrow{b_{j}}_j\}^{j\in J'_m}, \Pred_m, \Post_m}
      {\ostate{s_{i}^{i \in L_m}} \xrightarrow {v_m}
        \ostate{s_{i}^{\prime\ i \in L_m}}}
      %\land
      %Leaves(\pNet_m) = \overline{pLTS}^{L_k})
      \\
      I' = \biguplus_{m\in I_k}\!\! I_m'
      \\ J' = \biguplus_{m\in I_k}\!\! J'_m \uplus J_k  \\
      \Pred = \bigwedge_{m\in I_k}\!\! \Pred_m \land
      \MkPred(SV,v_m^{m\in I_k},b_j^{j\in J_k},v)\\
      \forall j\!\!\in\!\! J_k. {\tt 
        fresh}(b_j) \\ {\tt fresh}(v) \\ 
      \forall i\in
      L\backslash I'.\,s'_i=s_i 
    }
    {p = \mylangle \pNet_i^{i\in I}, S_j^{j\in J}, \symb{SV}_k^{k\in K}\myrangle
      \models
      {\inferrule*[myfraction=\reddottedrule]
        {\{s_i\xrightarrow{a_i}_i s_i^{\prime}\}^{i\in I^\prime},
        \{\xrightarrow{b_j}_j\}^{j\in J^\prime}, \Pred, \uplus_{m\in I_k} 
        \Post_m}
        {\ostate{s_i^{i\in L}} \xrightarrow {v}
          \ostate{s_i^{\prime i\in L}}}
      }
    }
    $

  \medskip  
\end{definition}

To have some practical interest, it is important to know when this
algorithm terminates. The following theorem shows that an open-pNet
with finite synchronization sets, finitely many leaves and
holes, and each pLTS at leaves having a finite number of states and
(symbolic) transitions, has a finite automaton. The proof can be found
in \cite{henrio:Forte2016}. 

In rule TR2, the generated predicate is composed of the conjunction of
the predicates of the subnets' OTs, with the additional part encoding
the application of the chosen synchronisation vector.
In \cite{henrio:Forte2016} this last part is defined as:
\[\MkPred(SV_k, a_i^{i\in I}, b_j^{j\in J}, v)\Leftrightarrow
\begin{array}{l}
\exists {(a'_i)}^{i\in I},
{(b'_j)}^{j\in J},v'.\, SV_k={(a'_i)}^{i\in I}, {(b'_j)}^{j\in J}\rightarrow v'
\\~~\land
\forall i\in I.\, a_i=a'_i\land \forall j \in J.\, b_j=b'_j \land v=v'
\end{array}\]

This definition is not constructive, but the existentialy quantified
variable sets here correspond the subsets of subnets and holes that
are effectively involved in vector $SV_k$.
Within our algorithm, these subsets have been computed by $Combining$ and
passed as arguments to the $Matching$ method, so
we can construct this predicate fragment as:

\[\Pred(SV, \overline{\pNet},\overline{S}, v) = 
\begin{array}{l}
\forall {(a'_i)}^{i\in I},
{(b'_j)}^{j\in J},v'.
\\
v_m=a'_i\land \, b_j=b'_j \land v=v' \land G_k
\end{array}\]
\TODO{Eric: to be checked}


\begin{theorem}[Finiteness of open-automata.]\\
Given an open pNet $\mylangle \overline{\pNet},\overline{S}, \symb{SV}_k^{k\in K}\myrangle$ with leaves $pLTS_i^{i\in L}$ and holes $Hole_j^{j\in
  J}$, if the sets $L$ and $J$ are finite, if the synchronization vectors of all pNets 
  included in  $\mylangle \overline{\pNet},\overline{S}, \symb{SV}_k^{k\in K}\myrangle$ 
  are finite, and if
$\forall i \in L.\, finite{(states(pLTS_i))} \text{ and } pLTS_i$
has a finite number of state variables, then Algorithm 1 terminates
and produces an open automaton 
$\mathcal{T}$ with finitely many states and transitions.


Given an open pNet $\mylangle \overline{\pNet},\overline{S}, \symb{SV}_k^{k\in
    K}\myrangle$ with leaves $pLTS_i^{i\in L}$ and holes $Hole_j^{j\in
  J}$,
build its semantics as in algorithm 1.

We have:

$$ finite{(L)} \land finite{(J)} \land \forall i \in L finite{(\{s_i\})}
  \to finite{(\mathcal{T})}$$
\end{theorem}


\section{Variable management}
\label{appendix:variables}
The variables in each synchronisation vector are considered local: for
a given pNet expression, we must have fresh local variables for each
occurrence of a vector (= each time we instantiate rule
Tr2). Similarly the state variables of each copy of a given pLTS in
the system, must be distinct, and those created for each application
of Tr2 have to be fresh and all distinct. This will be implemented
within the open-automaton generation algorithm, e.g. using name
generation using a global counter as a suffix.

\paragraph{Fresh variables}
Application of the semantic rules require generating a lot of fresh
names, for different kind of variables. We could use a global name
generator to guarantee unicity, but 
at the same time, we also hope them still
readable. Here we rename the variables with a regular format using the fresh function.
More precisely, the fresh function generates a new name adding a
suffix after the original name. The suffix contains three parts
combined by a colon.  


\begin{definition}[Fresh variable]\label{fresh-variable}
The format of \emph{fresh variable} (renaming) is defined as:
``$\emph{prefix : tree\ index\ :\ counter}$''.
\begin{itemize}
   \item[$\bullet$] $prefix$ identifies the kind of the
     variable. Current kinds are: sva\_<SV> (action variable in vector
     $SV$), ra (result action), hb\_<B> (behaviour of hole $B$).
   \item[$\bullet$] $tree\ index$ is the index of the node containing
     the variable in the tree-like structure of the pNet. 
   \item[$\bullet$] $counter$ is the current value of the corresponding counter.
\end{itemize}
\end{definition}

%\TODO{Option: Add the process and the vector ids ?}

%$Prefix$ avoids the confusion between variables from different structures with the same name by attaching the type of the structure. $Tree\ index$ is given to every node of the pNets to mention which node the variable belongs to as pNets has a tree-like structure. To each node, the tree index is always a number sequence of the tree index of its higher level and the index of the node in this level at the last. $A\ set\ of\ counters$ is used to count the current times the SV, Hole, subnet invoked, or the number of possible OT generated to provide an identity. 

For example, in the running example, in the raw output listing in
Appendix~ref{}, in the first OT, you find variables: 
\begin{itemize}
   \item $\OTvar{:hb\_B:13:1}$ that is the behaviour of hole ``B''
   \item $\OTvar{b1:sva\_SV0:1:1}$ variable ``b1'' from vector ``SV0''
   \item $\OTvar{:ra:1:1}$ result action of the current OT
\end{itemize}



\section{Algebra presentations}
\label{appendix:algpresentations}
In order to submit satisfiability problems to Z3 (for the predicates
in open transitions), we need to generate SMTlib programs, from the
pNet Algebra presentation and predicates.
More precisely, we need to translate to SMTlib:
\begin{itemize}
  \item the presentation of the action algebra
    (sorts and operators) that is defined for a given language (process calculus, or high level programming language),
    \item for a given pNet, the set of local constants (actions or auxiliary data) that are used in the pLTSs,
    \item for each open transition: the declaration of variables, and
      the predicate (including action expressions).
\end{itemize}

During this translation, in order to guarantee that the generated code
will cause no runtime errors during parsing and execution, we need
to ensure that all objects used in the SMTlib code are properly
declared, and that they are correctly typed.

Note that in principle, an action algebra corresponds to a given
high-level language (e.g. a process algebra), and that the algebra
presentation will be defined once and for all in the framework of the
pNet semantics of each specific language.

\subsection{Definition of an algebra presentation}
We have a minimal, predefined algebra presentation for all pNets, including
three basic sorts $Bool$, $Action$ and $Int$ and their
operators. Table \ref{Table:predefinedSorts} defines these elements.

In addition, and for convenience, we provide one generic construct for
parameterized actions named FUN, which can accept any number of
arguments of any sort. The result type, though, can only be $Action$,
in order to keep the type-checking simple (see next section).

\begin{table}\caption{\label{Table:predefinedSorts}\leftline{Algebra Presentation: predefined Sorts
  and Operators}}
	\begin{tabular}{p{3cm}p{3cm}p{6cm}}
		\hline\specialrule{0em}{1pt}{1pt}
		Sort & Constructors & Auxiliary Operators
                \\\specialrule{0em}{1pt}{1pt}
		\hline\specialrule{0em}{3pt}{3pt}
		Bool    			&
                $\texttt{true},\ \texttt{false}$&
                $\land,\ \lor,\ \neg,\ \implies$
                \\\specialrule{0em}{1pt}{1pt} 
		Action 			&  $\texttt{FUN}$ &
                \\\specialrule{0em}{1pt}{1pt}
		Int 				&
                ${0, \{i, -i\}_{i \in \texttt{Nat}}}$  &
                $- \texttt{(unary)},\ +,\ -
                \texttt{(binary)},\ \times,\ \div, \texttt{etc.}$
                \\\specialrule{0em}{1pt}{1pt}
                \textsl{for any sort} & & $=,\ \ne$
		\\\hline
	\end{tabular}
\end{table}

\begin{table}\caption{\label{table:BIPoperators}\leftline{Additional
      operator for the BIP algebra}}
	\begin{tabular}{p{3cm}p{3cm}p{6cm}}
		\hline\specialrule{0em}{1pt}{1pt}
		Sort & Constructors & Auxiliary Operators
                \\\hline\specialrule{0em}{1pt}{1pt} 
		Action 			&  $\texttt{FUN\_Action\_Bool}$ &
		\\\hline
	\end{tabular}
\end{table}

For a given language, or for a given use-case, the designer can
declare more sorts and operators, using our pNet API.
As an example, a (value-passing) CCS action algebra, where we assume a
single auxiliary value domain ``Data'', can be defined as:

\begin{example}
  \begin{itemize}
    \item[]
    \item $Sorts_{CCS} = \{Action, Channel, Data, Int, Bool\}$
    \item $Constrs_{CCS} =\\
    \texttt{Emit}: 2, \{(Chan\_E:Channel),(Value\_E:Data)\}->Action\\
    \texttt{Receive}: 2, \{(Chan\_R:Channel),(Value\_R:Data)\}->Action\\
    \texttt{Tau}: 0, \{\}-> Action\\
    \texttt{... and all predefined operators}$
  \end{itemize}
\end{example}

\begin{table}\caption{\label{table:CCSalgebra}\leftline{Additional
      sorts and operators for the CCS algebra}}
	\begin{tabular}{p{3cm}p{3cm}p{6cm}}
		\hline\specialrule{0em}{1pt}{1pt}
		Sort & Constructors & Auxiliary Operators
                \\\specialrule{0em}{1pt}{1pt}
		\hline\specialrule{0em}{3pt}{3pt}
		Channel, Data    			&
                $\emptyset$&
                $\emptyset$
                \\\specialrule{0em}{1pt}{1pt} 
		Action 			&  $\texttt{Emit(c,v)},\texttt{Receive(c,v)},\texttt{Tau}$ &
		\\\hline
	\end{tabular}
\end{table}


Then in pNet API these operators or constants can be declared as:
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily, language=java, frame=single]
AlgebraSort Action = new AlgebraSortImpl("Action");
AlgebraSort Channel = new AlgebraSortImpl("Channel");
AlgebraSort Data = new AlgebraSortImpl("Data");
Action.addConstructor("Emit", {"Chan_E", "Value_E"}, {Channel, Data});
Action.addConstructor("Receive", {"Chan_E", "Value_E"}, {Channel, Data});
Action.addConstructor("Tau");
\end{lstlisting}

%\subsection{Constants and variables in pNets and in open transitions}
\subsection{Extended presentation, and Environment}

In addition to the objects defined in the Algebra Presentation, there are
specific objects that are introduced by the pNet construction, and by
the semantic rules used to build the open transitions and their
predicates. This includes, for a pNet $pnet$
\begin{itemize}
\item $Const(pnet)$: Constants from the pLTSs (controllers) transitions: these are
  new constant constructors, usually of sort Action, local to an
  instance of a controller. The pNet definition requires that all
  these constants are distinct from each other.
\item $SVars(pnet)$: State variables of the controllers. Here also they are required
  to be distinct from those of other controllers.
\item $IVars(pnet)$: Input variables of the controllers.
\item $FVars(pnet,ot)$: Several kinds of ``fresh'' variables, created by application of
  rule Tr2, during the construction of each open transition $ot$:
  Action variables for the behaviour of holes and the 
  resulting actions of transitions, variables created during the cloning
  of synchronisation vectors.
\end{itemize}

\def\EPres{\mathcal{P}}
\def\EEnv{\Gamma}

All variable sets above include their sort.
To define the typing rules for expressions and the translation
functions, for any pNet $pnet$ and open transition $ot$, we define an
extended presentation $\EPres_{pnet}$ and environment $\EEnv_{pnet,ot}$ that includes all of the
objects above:

\begin{definition}
  Given an algebra presentation $\APres_{pnet}=<Sorts,Constrs,Ops>$ and a pNet $pnet$, we
  construct:
  \begin{itemize}
  \item An extended presentation $\EPres_{pnet}<Sorts,Constrs \cup Const(pnet),Ops>$.
  \item For a given open transition $ot$, an environment
    $\EEnv_{pnet,ot}=SVars(pnet) \cup IVars(pnet) \cup FVars(pnet,ot)$. 
  \end{itemize} 
\end{definition}



\section{Well-formness and typing of expressions}

The purpose of this section is to define static semantic notions that
will guarantee that the translation to the SMT language will be
correct, i.e. will not yield errors at runtime. This includes
well-formness (all sorts, operators, variables are defined, and
expressions respect the arity of operators), and typing rules.
%\TODO{Eric: refer in the appendix header}

\begin{definition}
  Given a presentation $\EPres$ (possibly extended) and an environment $\EEnv$:
  \begin{itemize}
  \item $\EEnv$ is well-formed if all sorts in $\EEnv$ are
    defined in $\EPres$
  \item an expression is well-formed if all its operators are defined
    in $\EPres$, and used with the proper arity, and all its
    variables are defined in $\EEnv$
  \item an expression is well-typed if it can be typed by the typing
    rules in table \ref{table:typing-rules}
  \end{itemize}
\end{definition}

The following judgment, and the typing rules in table
\ref{table:typing-rules} can be used to check both the wellformedness
and well-typing of expressions in a pNet or in an open transition,
given the corresponding $\EPres$ and $\EEnv$.

%\begin{table}\caption{\leftline{Typing judgment for Expressions in Open pNets}}
\vspace{1ex}
\noindent
\begin{tabular}{p{5cm}p{7cm}}
		\hline\specialrule{0em}{3pt}{3pt}
%%		$\EEnv \vdash \diamond$ 					& $\EEnv$ is a well-formed environment 					\\\specialrule{0em}{1pt}{1pt}
%%		$\EEnv \vdash A$ 							& A is a well-formed type in $\EEnv$	 					\\\specialrule{0em}{1pt}{1pt}
		$\EPres,\EEnv \vdash M: A$
                & M is a well-formed term of type A in $\EPres,\EEnv$			\\\specialrule{0em}{1pt}{1pt}
		\specialrule{0em}{3pt}{3pt}\hline
	\end{tabular}
%\end{table}	

\begin{table}\caption{\leftline{Type Rules for Open pNets}}
  \label{table:typing-rules}
	\begin{tabular}{p{5cm}p{5cm}p{2.5cm}}
		\hline\specialrule{0em}{3pt}{3pt}
		%% (Env $\varnothing$) 								
		%% & 										
		%% &					\\\specialrule{0em}{1pt}{1pt}
            %% $\dfrac{ }{\varnothing \vdash \diamond}$			
            %% & %$\dfrac{\EEnv \vdash A ~~ x\ }{\varnothing \vdash \diamond}$
            %% &					\\\specialrule{0em}{3pt}{3pt}
		%% (Type Bool) 										
		%% &(Type Action) 						
		%% &(Type Int)			\\\specialrule{0em}{1pt}{1pt}
		%% $\dfrac{\EPres \vdash Bool~~\EEnv \vdash \diamond}{\EPres,\EEnv \vdash Bool}$ 
		%% & $\dfrac{\EPres \vdash Action~~\EEnv \vdash \diamond}{\EPres,\EEnv \vdash Action}$ 
		%% & $\dfrac{\EPres \vdash Int~~\EEnv \vdash \diamond}{\EPres,\EEnv \vdash Int}$        \\\specialrule{0em}{3pt}{3pt}
		(Var x) 										
		& 						
		&			\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{\EEnv \vdash x:A}{\EPres,\EEnv \vdash x:A}$ 
		&  
		&       		\\\specialrule{0em}{5pt}{5pt}
		\multispan{2} (Binary operators, e.g.: $\land, \lor$ for Booleans, $+, -, \times, \div, \le, \ge$ for integers, etc.)								
							
		& 			\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{\EPres \vdash BinOp :: ty1, ty1 \rightarrow ty2 ~~\EEnv \vdash x_1:ty1 ~~\EEnv \vdash x_2:ty1}{\EPres,\EEnv \vdash x_1 ~BinOp~ x_2:ty2}$ 
		& 
		&       		\\\specialrule{0em}{3pt}{3pt}
		\multicolumn{2}{l}{(Unary operators, e.g. $\lnot$ for Booleans, - for integers)}	
                
		& 			\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{\EPres \vdash UnOp :: ty1 \rightarrow ty2 ~~\EEnv \vdash x:ty1}{\EPres,\EEnv \vdash Unop~x:ty2}$   
		&&       		\\\specialrule{0em}{5pt}{5pt}
		(Polymorphic EQ and NEQ)							
		&					
		&
                                         \\\specialrule{0em}{3pt}{3pt}
		$\dfrac{\EPres \vdash A  ~~\EEnv \vdash x_1:A ~~\EEnv \vdash x_2:A}{\EPres,\EEnv \vdash x_1 = x_2:Bool}$ 
		& 
		$\dfrac{\EPres \vdash A  ~~\EEnv \vdash x_1:A ~~\EEnv \vdash x_2:A}{\EPres,\EEnv \vdash x_1 \ne x_2:Bool}$ 
		
		&       		\\\specialrule{0em}{5pt}{5pt}
		(Overloaded FUN)							
		&					
		& 			\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{\EPres \vdash \texttt{FUN} :: A_1,...,A_n \rightarrow Action ~~\EPres \vdash A_1~~...~~\EPres \vdash A_n ~~\EEnv \vdash x_1:A_1~~...~~\EEnv \vdash x_n:A_n}{\EPres,\EEnv \vdash \texttt{FUN}(x_1,...,x_n):Action}$ 
		& 
		&			\\
		\specialrule{0em}{5pt}{5pt}\hline
	\end{tabular}
\end{table}	

\begin{remark}
  These rules provide a simple type-checking algorithm: if all
  variables in an expression are known in $\EEnv$, then a bottom-up
  application of the rules will decide whether the expression is
  well-typed, and compute the type of each sub-expression.
\end{remark}


\section{Management of state variables}
\label{appendix:translating-assignments}
In a pLTS, there may be several incoming transitions 
that assign potentially different values to a state variable.
To handle such cases, the algorithm manages for each pLTS state, as a
list of expressions collected from the assignments of each state
variable $v$ (as registered in the incoming OTs).
%% The list we used contains triples <$v$, $S$, $AssignRH$> 
%% where $v$ is the variable in pLTS, $S$ is its owner state and
%% $AssignRH$ is a list of expressions over other variables in the right
%% hand side of assignments of $v$.
% As a pragmatic extension to the formal definition, we also manage
% ``global variables'', defined in all states of the pLTS.
For a global state in the open automaton, getting the set of state
variables (which may be used in a transition) will simply be the union
of state variables of the individual pLTS states constituting this
global state, as variables of different pLTS are distinct.

 We define:
\begin{itemize}
  \item $SVars(gs)$ the state variables of all states in the global
    state $gs$
  \item $Assigns(svar)$ the set of possible assignments of variable
      $svar$.
\end{itemize}
These will be used when translating the predicates into SMTlib
language.


\section{Translation to SMTlib input language}
\label{appendix:mapsmt}
The pNet elements, as defined above, can be full translated into
SMT-LIB language (\ref{SMTlibv2.5}), but there are a number of differences in the
structure of the models/languages, so the translation is not trivial.

In this section we shall define separately the translation of the
extended algebra presentation for one pNet (so it will be common for
the study of all OTs of one use-case); and the translation of each
predicate (of an open-transition) of this pNet. 

\def\translate{~\lhook\joinrel\longrightarrow}

\vspace{1ex}\noindent
%\begin{table}\caption{\leftline{Mapping}}
	\begin{tabular}{p{3cm}p{9cm}}
		\hline\specialrule{0em}{1pt}{1pt}			
		(Presentation)							
		&								\\\specialrule{0em}{1pt}{1pt}		
		&$Sorts \& Constructors \translate$	declare-datatypes				\\\specialrule{0em}{1pt}{1pt}
		&$Operators \lhook\joinrel\longrightarrow$	declare-function		\\\specialrule{0em}{1pt}{1pt}
		(Predicate)							
		&								\\\specialrule{0em}{1pt}{1pt}
		&$\EEnv ~~\lhook\joinrel\longrightarrow$	declare-const		\\\specialrule{0em}{1pt}{1pt}
		&$Pred ~~\lhook\joinrel\longrightarrow$	 assert		\\\specialrule{0em}{1pt}{1pt}
		&$\texttt{FUN}(x_1,...,x_n)$		\\\specialrule{0em}{1pt}{1pt}
		&$\texttt{pNet expression} ~~\lhook\joinrel\longrightarrow$ SMTLib expression	\\\specialrule{0em}{1pt}{1pt}
		&$...$	\\\specialrule{0em}{1pt}{1pt}
		\specialrule{0em}{1pt}{1pt}\hline
	\end{tabular}
%\end{table}

\smallskip
%% \ERIC{My plan here is to provide the translation principles as some
%%   high-level pseudo code, together with precise definition of the
%%   translation functions of a presentation+environment, and of a
%%   predicate (including expressions)}

In the following definitions, we use abstract functions corresponding to
SMTlib/Z3 constructs. In practice they can be implemented either as
SMTLib scripting programs, or as calls to the Z3 java API.

\subsubsection{Presentation Translation} \TODO{Duplicate ?}
We define here the translation of the algebra presentation, extended
with the constant operators collected from the pNet. It produces the
declaration of sorts (excepted Bool and Int) with their constructors
and selectors as \texttt{declare-datatypes}, and the declaration of
auxiliary operators as \texttt{declare-function} constructs.
For sorts, we must distinguish the case of mutually defined sorts
(e.g. edges and vertices in a graph), that must be declared within a
single \texttt{declare-datatypes} construct. For this we define:

\begin{definition}
Define the (strict) order "is-using" between sorts $S1 is-using S2$ iff $S2$
occurs as the sort of one argument in the constructors of $S1$.
\end{definition}


\begin{lstlisting}
Let Pres = <Sorts, Constrs, Ops> an extended presentation
(i.e. including the constants from the pnet),
- define MySorts = Sorts \ {Bool, Int}
- compute the strongly connected components in the graph
  of MySorts with respect to the relation is-using
- for each SCC in this graph, construct: 
  datatype-declaration = TrPresentation (Pres, SCC)
- for each other operator op in Ops, construct:
  function-declaration = TrPresentation (Pres, op)
\end{lstlisting}

%\begin{table}\caption{\leftline{Rules for TrPresentation}}
%  \label{table:TrPresentation}
\noindent
\begin{tabular}{p{5cm}p{5cm}p{2.5cm}}
		\hline\specialrule{0em}{3pt}{3pt}
		\multicolumn{2}{l}{One datatype declaration for each SCC}
                
		& 			\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{name=name(Sort) \qquad constrs=Constrs(name) %\qquad sels=Sels(name)
                  \translate constrs}
                       {SCC \translate
                  \texttt{(declare-datatypes () $name$ (map $\translate constrs$))}}$ 

		&&       		\\\specialrule{0em}{1pt}{1pt}
		\multicolumn{2}{l}{Constants: }	
                
		& 			\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{arity(constr)=0}
                       {constr \translate \texttt{name($constr$)}}$
                
		&&       		\\\specialrule{0em}{1pt}{1pt}
		\multicolumn{2}{l}{Other constructors: }	
                
		& 			\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{n = arity(constr) \neq 0 \qquad |sels|=n
                  \qquad sels =  BuildSels(constr)}
                       {constr \translate \texttt{(name($constr$) . sels)}}$
                       
		&&       		\\\specialrule{0em}{1pt}{1pt}
		\multicolumn{2}{l}{Auxiliary operators: }	
                
		& 			\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{op : sort_1, ..., sort_n : sort}
                       {op \translate \texttt{(declare-fun name($op$) ($sortname_1
                           ... sortname_n$) $sortname$)}}$
                       
		&&       		\\\specialrule{0em}{1pt}{1pt}
		\multicolumn{2}{l}{Special case of FUN: }	
                
		& 			\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{}
                       {FUN \translate \texttt{map $\translate CollectFunTypes(pNet)$ }}$
                       
		&&       		\\\specialrule{0em}{1pt}{1pt}
		$\dfrac{}
                       {argstypes \translate \texttt{(declare-fun
                           $BuildFunInstance(argstypes)$ (map name
                           $argstypes$) Action) }}$
                       
		&&       		\\\specialrule{0em}{1pt}{1pt}
		\hline
\end{tabular}
%\end{table}

\smallskip
Where:
\begin{itemize}
  \item the $BuildSels$ function, for a constructor with $n$ arguments,
argument sorts $sort_i$, and selector names $sel_i$, builds the list
$\{(sel_i, sort_i)\}_{i\in[1..n]}$.
\item the $CollectFunTypes$ function collects all possible instances
  of the overloaded FUN argument types found in the pNet, as computed by the typing
  rules; and $BuildFunInstance$ use these argument types as suffixes
  to disambiguate 
\end{itemize}


\begin{example}
  For the CCS presentation above, we would get (in SMTLib syntax):
\begin{lstlisting}
  (declare-datatypes Data ())
  (declare-datatypes Channel ())
  (declare-datatypes ()
      ((Action (Emit (Chan_E Channel) (Value_E Data))
               (Receive (Chan_R Channel) (Value_R Data))
               Tau )))
  \end{lstlisting}
\end{example}

\TODO{Need to add an example with 2 instances of FUN}

 
\subsubsection{Predicate translation}

Each time we submit each open transition to Z3 module, we translate
  its predicate into the SMTlib language  and send it for satisfiability
  checking. Every term of the predicate is declared as an
  \texttt{assert} in Z3. A constant action or a parameterized
  expression is easy to get from the internal list storing the objects
  while all the variables are not declared at the beginning. So we
  declare them before the submission of a predicate term with the API
  method conducting \texttt{declare-const}.

The second part of the translation function is called for each open
transition. More precisely we need here:

Let Pres = <Sorts, Constrs, Ops> be the extended presentation
and OT = <Leaves, Holes, Pred, Assign> an open transition.
\begin{itemize}
\item compute the environment $\EEnv=\EEnv_{pnet,OT}$ collecting
all variables used in OT.
\item check that all pLTS labels (action, guard, assignment) in
the transition, the OT predicate, and the OT assignments are
well-formed and well-typed.
\item for each start global state $gs$ of the open transition, using $SVar(gs)$
  get the state variables and their possible evaluations from all the state in $gs$.
  Then use Assigns(x) as the set of evaluations of state variable x.
\item for each variable $v$ in $\EEnv$, construct:
  define-const = TrPredicate ($\EEnv ,v$).
%- turn the predicate into conjunctive normal form
\item for each conjunct $P_i$ in the predicate, construct:
  assert = TrPredicate $(P_i)$.
\end{itemize}

% \TODO{This is incomplete... Xudong: Conjunctive normal form, translation function for Boolean expressions, + assignments}

\noindent
\begin{tabular}{p{5cm}p{7cm}}
		\hline\specialrule{0em}{3pt}{3pt}
		\multicolumn{2}{l}{Variables:}
		\\
		$\dfrac{\EEnv \vdash x:A }
                       {x \translate \texttt{(declare-const x A)}}$&
		\\\specialrule{0em}{3pt}{3pt}
		Open transition: 
		\\
		$\dfrac{Pred \translate lst_1~~Ass \translate lst_2}{ot(Pred, Ass) \translate lst_1 lst_2}$
		\\\specialrule{0em}{3pt}{3pt}
		Predicate: & Predicate conjunct:
		\\
		$\dfrac{Pred = \bigwedge\limits_{k\in K}P_k}{Pred \translate \texttt{map} \translate P_k}$&	$\dfrac{P_k = op(args)}{P_k \translate \texttt{(assert (op map}\longrightarrow \texttt{args))}}$
		\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{\EEnv \vdash x:A }{Var(x) \longrightarrow \texttt{x}}$
		\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{arg = op'(args)~~op'\in Constr~~arity(op') = 0}{op' \longrightarrow name(op')}$
		\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{arg = op'(args)~~op'\in Constr~~arity(op')\neq 0}{op' \longrightarrow \texttt{(}name(op')~~map\longrightarrow args\texttt{)}}$
		\\\specialrule{0em}{3pt}{3pt}
		$\dfrac{arg = op'(args)~~op'\in Ops}{op' \longrightarrow \texttt{(}name(op')~~map\longrightarrow args\texttt{)}}$
		\\\specialrule{0em}{3pt}{3pt}
		Assignment: 
		\\
		$\dfrac{Ass = \bigwedge\limits_{k\in K}(x_k, a_k)~~x_k\in SVar(gs)~~a_k = Assigns(x_k)}{Ass \translate \texttt{map} \translate (x_k, a_k)}$
		\\\specialrule{0em}{3pt}{3pt}		
		$\dfrac{a_k = e_1,...,e_n}{(x_k, a_k) \translate \texttt{(assert (or (= }x_k\texttt{ map} \longrightarrow e_1\texttt{)}\texttt{...(= }x_k\texttt{ map} \longrightarrow e_n\texttt{)}  \texttt{))}}$
		\\\\\specialrule{0em}{1pt}{1pt}
	        \hline
\end{tabular}




\subsection{properties}
The rules in the sections above are meant to guarantee that no runtime
errors would occur when running Z3 from our algorithm. More precisely,
we ensure that:
\begin{itemize}
\item all datatypes, functions, variable used are declared,
\item datatypes declared are well-founded,
\item all expressions in declarations and assertions are well-typed.
\end{itemize}

  

\section{Full output for the FailureTimer open automaton}
\label{appendix:fullOutput}

\begin{lstlisting}[basicstyle=\scriptsize\ttfamily, frame=single]
	{s0---failure(true)-->s1, t0---start(true)-->t1},{---:hb_B:13:1-->},   
	(failure(true)=failure(b1:sva_SV0:1:1))
	/\(start(true)=start(b2:sva_SV0:1:1))
	/\(:hb_B:13:1=fail(b0:sva_SV0:1:1))/\((b1:sva_SV0:1:1=b2:sva_SV0:1:1)
	/\(~(b1:sva_SV0:1:1\/b2:sva_SV0:1:1)\/b0:sva_SV0:1:1))
	/\(_fail_=:ra:1:1),{t := Max}
OT ---------------------------------------------------------------------------
		<s0_t0>-----:ra:1:1----><s1_t1>

	{s0---resume(false)-->s0, t0---resume(false)-->t0},{---:hb_B:16:2-->},   
	(resume(false)=resume(b1:sva_SV1:1:2))
	/\(resume(false)=resume(b2:sva_SV1:1:2))
	/\(:hb_B:16:2=resume(b0:sva_SV1:1:2))/\((b1:sva_SV1:1:2=b2:sva_SV1:1:2)
	/\(~(b1:sva_SV1:1:2\/b2:sva_SV1:1:2)\/b0:sva_SV1:1:2)
	/\(_resume_=:ra:1:2),{}
OT ---------------------------------------------------------------------------
	<s0_t0>-----:ra:1:2----><s0_t0>

	{},{---:hb_B:118:6-->},(:hb_B:118:6=finish)/\(finish=:ra:1:6),{}
OT ---------------------------------------------------------------------------
	<s0_t0>-----:ra:1:6----><s0_t0>
 
	{s1---failure(false)-->s1, t1---start(false)-->t1},{---:hb_B:13:1-->},   
	(failure(false)=failure(b1:sva_SV0:1:1))
	/\(start(false)=start(b2:sva_SV0:1:1))
	/\(:hb_B:13:1=fail(b0:sva_SV0:1:1))/\((b1:sva_SV0:1:1=b2:sva_SV0:1:1)
	/\(~(b1:sva_SV0:1:1\/b2:sva_SV0:1:1)\/b0:sva_SV0:1:1))
	/\(_fail_=:ra:1:1),{}
OT ---------------------------------------------------------------------------
	<s1_t1>-----:ra:1:1----><s1_t1>

	{s1---resume(true)-->s0, t1---resume(true)-->t0},{---:hb_B:16:2-->},   
	(resume(true)=resume(b1:sva_SV1:1:2))
	/\(resume(true)=resume(b2:sva_SV1:1:2))
	/\(:hb_B:16:2=resume(b0:sva_SV1:1:2))/\((b1:sva_SV1:1:2=b2:sva_SV1:1:2)
	/\(~(b1:sva_SV1:1:2\/b2:sva_SV1:1:2)\/b0:sva_SV1:1:2))
	/\(_resume_=:ra:1:2),{}
OT ---------------------------------------------------------------------------
	<s1_t1>-----:ra:1:2----><s0_t0>

	{t1---tick-->t1},{},(t>0)/\(tick=:ra:1:3),{t := (t-1)}
OT ---------------------------------------------------------------------------
	<s1_t1>-----:ra:1:3----><s1_t1>

	{},{---:hb_B:118:6-->},(:hb_B:118:6=finish)/\(finish=:ra:1:6),{}
OT ---------------------------------------------------------------------------
	<s1_t1>-----:ra:1:6----><s1_t1>

	{s1---timeout-->s2, t1---timeout-->t0}, {},(t=0)/\(ask=:ra:1:4),{}
OT ---------------------------------------------------------------------------
	<s1_t1>-----:ra:1:4----><s2_t0>

	{s2---resume(false)-->s2, t0---resume(false)-->t0},{---:hb_B:16:2-->},   
	(resume(false)=resume(b1:sva_SV1:1:2))
	/\(resume(false)=resume(b2:sva_SV1:1:2))
	/\(:hb_B:16:2=resume(b0:sva_SV1:1:2))/\((b1:sva_SV1:1:2=b2:sva_SV1:1:2)
	/\(~(b1:sva_SV1:1:2\/b2:sva_SV1:1:2)\/b0:sva_SV1:1:2))
	/\(_resume_=:ra:1:2),{}
OT ---------------------------------------------------------------------------
	<s2_t0>-----:ra:1:2----><s2_t0>

	{s2---reset-->s0},{},(reset=:ra:1:5),{}
OT ---------------------------------------------------------------------------
	<s2_t0>-----:ra:1:5----><s0_t0>

	{},{---:hb_B:118:6-->},(:hb_B:118:6=finish)/\(finish=:ra:1:6),{}
OT ---------------------------------------------------------------------------
	<s2_t0>-----:ra:1:6----><s2_t0>
\end{lstlisting}

\subsection{Scaling up: several subsystems on the same bus}
\TODO{Not yet !}
\begin{figure}
    \centerline{\includegraphics[width=\linewidth]{XFIG/ScaleUp}}
    \caption{pNet encoding of the composition of two Failure Monitoring modules}  \label{schema:scaleup}
\end{figure}

We build a larger system by composing several subsystems. In the example here, we use two Failure Monitoring modules as the subsystems.
To compose them, a new controller is added for managing the reset function of the whole system. 
No matter which module behaves an "ask" to call for reset, the controller take the request. Then all of the modules conduct the "reset".
So two more new transitions are added to the Timer to make the module can reset at any state.

There are 327 satisfiable results, out of totally 97920 results, of the example computed in 105384 milliseconds.

\newpage
\begin{figure}
$\begin{array}{r@{}l}
    ot_1  = &\openrule{\{s0 \xrightarrow{\OTvar{fail(true)}} s1, t0 \xrightarrow{\OTvar{start(true)}} t1\}, ~~\{\xrightarrow{hb_1}\},~~\OTvar{fail(false)}=\OTvar{fail(}\OTvar{b}_1\OTvar{)}\\
    \OTland \OTvar{start(true)}=\OTvar{start(}\OTvar{b}_2\OTvar{)}\OTland hb_1=\OTvar{fail(}\OTvar{b}_0\OTvar{)}\\
    \OTland v_1=\OTvar{\underline{fail}}\OTland \OTvar{b}_1 = \OTvar{b}_2
    \OTland \OTvar{(}\OTvar{b}_1 \lor \OTvar{b}_2\OTvar{)} \Rightarrow \OTvar{b}_0, ~~\{t := Max\}}
    	   {\ostate{s0,t0} \xrightarrow{v_1} \ostate{s1,t1}}\\
\end{array}$
  \smallskip
  
$\begin{array}{r@{}l}
    ot_2  = &\openrule{\{s0 \xrightarrow{\OTvar{resume(false)}} s0, t0 \xrightarrow{\OTvar{resume(false)}} t0\}, ~~\{\xrightarrow{hb_2}\},~~\OTvar{resume(false)}=\OTvar{resume(}\OTvar{b}_1\OTvar{)}\\
    \OTland \OTvar{resume(false)}=\OTvar{resume(}\OTvar{b}_2\OTvar{)}\OTland hb_2=\OTvar{resume(}\OTvar{b}_0\OTvar{)}\\
    \OTland v_2=\OTvar{\underline{resume}}\OTland \OTvar{b}_1 = \OTvar{b}_2
    \OTland \OTvar{(}\OTvar{b}_1 \lor \OTvar{b}_2\OTvar{)} \Rightarrow \OTvar{b}_0, ~~\{\}}
    	    {\ostate{s0,t0} \xrightarrow{v_2} \ostate{s0,t0}}\\
  \end{array}$
\smallskip
  
$\begin{array}{r@{}l}
    ot_3  = &\openrule{\{\}, ~~\{\xrightarrow{hb_3}\},~~hb_3=\OTvar{finish}\OTland v_3=\OTvar{finish}, ~~\{\}}
    	    {\ostate{s0,t0} \xrightarrow{v_3} \ostate{s0,t0}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_4  = &\openrule{\{s1 \xrightarrow{\OTvar{fail(false)}} s1, t1 \xrightarrow{\OTvar{start(false)}} t1\}, ~~\{\xrightarrow{hb_4}\},~~\OTvar{fail(false)}=\OTvar{fail(}\OTvar{b}_1\OTvar{)}\\
    \OTland \OTvar{start(false)}=\OTvar{start(}\OTvar{b}_2\OTvar{)}\OTland hb_4=\OTvar{fail(}\OTvar{b}_0\OTvar{)}\\
    \OTland v_4=\OTvar{\underline{fail}}\OTland \OTvar{b}_1 = \OTvar{b}_2
    \OTland \OTvar{(}\OTvar{b}_1 \lor \OTvar{b}_2\OTvar{)} \Rightarrow \OTvar{b}_0, ~~\{\}}
    	   {\ostate{s1,t1} \xrightarrow{v_4} \ostate{s1,t1}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_5  = &\openrule{\{s1 \xrightarrow{\OTvar{resume(true)}} s0, t1 \xrightarrow{\OTvar{resume(true)}} t0\}, ~~\{\xrightarrow{hb_5}\},~~\OTvar{resume(true)}=\OTvar{resume(}\OTvar{b}_1\OTvar{)}\\
    \OTland \OTvar{resume(true)}=\OTvar{resume(}\OTvar{b}_2\OTvar{)}\OTland hb_2=\OTvar{resume(}\OTvar{b}_0\OTvar{)}\\
    \OTland v_5=\OTvar{\underline{resume}}\OTland \OTvar{b}_1 = \OTvar{b}_2
    \OTland \OTvar{(}\OTvar{b}_1 \lor \OTvar{b}_2\OTvar{)} \Rightarrow \OTvar{b}_0, ~~\{\}}
    	    {\ostate{s1,t1} \xrightarrow{v_5} \ostate{s0,t0}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_6  = &\openrule{\{t1 \xrightarrow{\OTvar{tick}} t1\}, ~~\{\},~~t\neq 0\OTland v_6=\OTvar{tick}, ~~\{t := t-1 \}}
    	   {\ostate{s1,t1} \xrightarrow{v_6} \ostate{s1,t0}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_7  = &\openrule{\{\}, ~~\{\xrightarrow{hb_7}\},~~hb_7=\OTvar{finish}\OTland v_7=\OTvar{finish}, ~~\{\}}
    	    {\ostate{s1,t1} \xrightarrow{v_7} \ostate{s1,t1}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_8  = &\openrule{\{s1 \xrightarrow{\OTvar{timeout}} s2, t1 \xrightarrow{\OTvar{timeout}} t0\}, ~~\{\},~~t=0\OTland v_8=ask, ~~\{\}}
    	   {\ostate{s1,t1} \xrightarrow{v_8} \ostate{s2,t0}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_9  = &\openrule{\{s2 \xrightarrow{\OTvar{resume(false)}} s2, t0 \xrightarrow{\OTvar{resume(false)}} t0\}, ~~\{\xrightarrow{hb_9}\},~~\OTvar{resume(false)}=\OTvar{resume(}\OTvar{b}_1\OTvar{)}\\
    \OTland \OTvar{resume(false)}=\OTvar{resume(}\OTvar{b}_2\OTvar{)}\OTland hb_9=\OTvar{resume(}\OTvar{b}_0\OTvar{)}\\
    \OTland v_9=\OTvar{\underline{resume}}\OTland \OTvar{b}_1 = \OTvar{b}_2
    \OTland \OTvar{(}\OTvar{b}_1 \lor \OTvar{b}_2\OTvar{)} \Rightarrow \OTvar{b}_0, ~~\{\}}
    	    {\ostate{s2,t0} \xrightarrow{v_9} \ostate{s2,t0}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_{10}  = &\openrule{\{s2 \xrightarrow{\OTvar{reset}} s0\}, ~~\{\},~~v_{10}=\OTvar{reset}, ~~\{\}}
    	   {\ostate{s2,t0} \xrightarrow{v_{10}} \ostate{s0,t0}}\\
\end{array}$
\smallskip

$\begin{array}{r@{}l}
    ot_{11}  = &\openrule{\{\}, ~~\{hb_{11}\},~~hb_{11}=\OTvar{finish}\OTland v_{11}=\OTvar{finish}, ~~\{\}}
    	   {\ostate{s2,t0} \xrightarrow{v_{11}} \ostate{s2,t0}}\\
\end{array}$
\caption{The open transitions of the open automaton}  \label{schema:ots}
\end{figure}

\newpage
\end{document}




\subsection{Simplification of Predicates}
\TODO{I keep it here for now, but I think we shall not include it in
  the FM submission, this section is not mature enough}

\ERIC{: motivated, add refs, and an abstract presentation of stuff
  from pages 19-20. The following is NOT a good example, we should
  rather use a pNet with at least 2 levels, to have real intermediate
variables; here b0, b1, b2 are NOT intermediate variables... and the
predicate simplification is using `some form of ``tautology checking''
rather than rewriting.}

Before:
  	\begin{mathpar}
	\inferrule*[myfraction=\reddottedrule]
	{\{s0~{\xrightarrow{fail(true)}} ~s1, t0~{\xrightarrow{start(true)}} ~t1\}
	  \{\xrightarrow{hb}\},\\
\qquad b1=true \land b2=true \land hb=fail(b0) \land b1=b2 \land (b1\cup b2
\implies b0) \land v=\underline{fail}, \{t := 4\}
        }
	{<s0,t0> \xrightarrow {v} <s1,t1>}
	\end{mathpar}

After:
          	\begin{mathpar}
	\inferrule*[myfraction=\reddottedrule]
	{\{s0~{\xrightarrow{fail(true)}} ~s1, t0~{\xrightarrow{start(true)}} ~t1\}
	  \{\xrightarrow{hb}\}, hb=fail(true) \land v=\underline{fail}, \{t := 4\}
        }
	{<s0,t0> \xrightarrow {v} <s1,t1>}
	\end{mathpar}


\subsection{Elimination of intermediate variables}

\QIN{
We apply several structural rules to generate the predicates restricting the composition of the subnets by synchronization vectors.
The predicates may contain some redundancy if there are variables in middle level are matching other variables both in lower and higher level at the same time. 
}

We already have the operational semantics of open pNets restricting the open transitions using two rules.
The generated equations in the $predicates$ contain either intermediate variables or ground ones, but what we want is the equation between ground terms. 

\QIN{
We want to reason about the equations to eliminate the redundancy. 
Considering pNet has a special tree-structure, the replacement between equations should be one-way, the direction is from leaves to the top level, until the root pNet node. 
And it is easy to figure out the intermediate variables by the constraint rules.
While it is not needed figure out if an equation is "true" , it can be left to Z3.
}

\begin{definition}[Intermediate Variable]
\paragraph{}
When applying Tr1, we do not collect intermediate variables. Though the result action might be the intermediate one between two result action from the SV if it is not the root of the pNet, it will be determined at the higher level instead of at the leaves.

\begin{description}
	\item[{\bf Using the parameters from Tr1:}]
\end{description}

\[ InterVar(OT) = \emptyset \]

\paragraph{}
When it comes to a pNet node, all the variables from the sources mentioned above should be contained in the $InterVar$ together with the intermediate variables from the subnets. Whatever its subnet is a pLTS or pNets. At the same time, the subnet's result action should be add into the $InterVar$.

If the result of the SV also occurs in its parameters, it means the action from the subnet will be propagated as the result action of the open transition on this level through this SV result action. So it is also the intermediate variable in such situation.

\begin{description}
	\item[{\bf Using the parameters from Tr2:}]
\end{description}
\[ InterVar(OT) = \bigcup_{m\in I_k}{InterVar(OT_m)}  \bigcup_{m\in I_k}{\{v_m\}} \cup{InterVar(SV_k)} \]
$$ InterVar(SV_k)=\left\{
\begin{aligned}
\emptyset & , & \alpha_{k}^{'} \not\in \bigcup_{m\in I_k \uplus J_k}{\{\alpha_{m}\}}\\
{\alpha_{k}^{'}} & , & \alpha_{k}^{'} \in \bigcup_{m\in I_k \uplus J_k}{\{\alpha_{m}\}}
\end{aligned}
\right.
$$

\begin{itemize}
	\item $OT$ is an open transition.
	\item $I, J$ is the set of indices.
	\item $k$ is the indices of the synchronization vectors.
	\item $SV$ is the set of the synchronization vectors.
	\item $Vars()$ is the function that gets all the variables in the object.
	\item $\alpha$ and $\alpha^{'}$ is the element of the  the synchronization vector.
\end{itemize}
\end{definition}

Definition of the intermediate variable shows that elimination should be done every time Tr2 is applied.

%\texttt{\\
%1. Classify the ground and intermediate variables.
%\begin{itemize}
%    \item (1) The predicates of the subnets: The result actions of the sub-OTs. Others are ground.
%    \item (2) The chosen synchronization vector: If the result is also one of the elements, it is also the intermediate variable. Otherwise, all of the parameters are ground.
%    \item (3) Hole behaviours: Ground.
%    \item (4) The result action: Not sure. But it must be ground if it is on the root node.
%\end{itemize}
%2. Using a list {\em equations} to store the equations containing the intermediate variable. {\em equations} is a hasp map storing the corresponding ground terms of the variable by its name. Its structure likes <String, List<Expression> >. It will be updated during the later deduction .\\
%3. The guards from the subnets are kept, waiting for further substitution.\\
%4. Deduct out the new equations using the redundant Pred got in matching().\\
%    Checking two sides of the equations.
%\begin{itemize}
%   \item If both are ground, then generate a new equation with them, add it to Pred.
%   \item If the right-hand-side or left-hand-side is intermediate, then find the ground term of it from the list then generate a new equation and add it to Pred.
%   \item If both are intermediate, then check the list {\em equations}
%   	\begin{itemize}
%  		\item If list contain both lhs and rhs, then get the corresponding ground terms of them, generate the new equation with the ground terms. Add it to Pred.
%   		\item If list only contain lhs, store the rhs in {\em equations} with lhs's corresponding ground terms.
%   		\item If list only contain rhs, store the lhs in {\em equations} with rhs's corresponding ground terms.
%   		\item Otherwise, skip this turn.
%         \end{itemize}
%\end{itemize}
%5. Search the inter in the guards if it is found, subsititute it with the ground. Then conduct step 2 again.\\
%}

\paragraph{Term Rewriting Rules}
Predicates already have a format declaring what it verifies. According to that previous work, we define the predicates.
Let $\mylangle\overline{\pNet},\overline{S},\symb{SV}_k^{k\in K} \myrangle$
be a pNet. Choose a synchronisation vector $SV=clone(SV_k) ={(a'_i)}^{i\in I}, {(b'_j)}^{j\in J}\rightarrow v' \, ,G_k $, for $k\in K$. The
predicate $\Pred$ relating
the actions of the involved sub-pNets and the resulting actions.
\begin{definition}[Predicate]
\[\Pred(SV, \overline{\pNet},\overline{S}, v) = 
\begin{array}{l}
\forall {(a'_i)}^{i\in I},
{(b'_j)}^{j\in J},v'.
\\
v_m=a'_i\land \, b_j=b'_j \land v=v' \land G_k
\end{array}\]
\end{definition}
\QIN{
The new predicates introduce more hypotheses for term rewriting. However, not every variable can be substituted. 
Here we introduce several rewriting rules.
}

\begin{align*}
   &v_m=a'_i \land v_m=v'_m \rightarrow a'_i = v'_m &[RL-1]\\\\
   &v_m=a'_i \land v=v' \rightarrow v_m=v ~~ \texttt{if} ~~ a'_i = v', ~~ a'_i,v' \in InterVar &[RL-2]\\\\
   &v_m=foo'_i(a_1,...,a_p,...,a_n) \land v=v' \rightarrow v_m=foo'_i(a_1,...,v,...,a_n) \\ 
   &\hspace{15em}\texttt{if} ~~ a_p = v', ~~ a_p,v \in InterVar &[RL-3]\\\\
   &b_j=b'_j \land v=v' \rightarrow b_j=v ~~ \texttt{if} ~~ b'_j = v', ~~ b'_j,v' \in InterVar &[RL-4]\\\\
   &b_j=foo'_i(a_1,...,a_p,...,a_n) \land v=v' \rightarrow b_j=foo'_i(a_1,...,v,...,a_n) \\ 
   &\hspace{15em}\texttt{if} ~~ a_p = v', ~~ a_p,v \in InterVar &[RL-5]\\\\
\end{align*}

\QIN{
Rule RL-1 applies on when the result action of subnets matching other arguments of the chosen SV. It merges the predicates from the subnets with the new generated predicates.
Rule RL-2 shows that if the result of the SV is also in its arguments, we can straightly get an equation between the subnet action and  the result action. RL-3 is the situation that there is an expression instead of a variable contains an intermediate argument. The substitution will only occur on the argument.
Actually, what happened is similar if there is a hole behaviour instead of a subnet result action attending in the equation. So we get RL-4 and RL-5. However, every hole behaviour should be kept through out the computing. That's why there no rule similar to the RL-1 for hole behaviours.
}

