\documentclass{lncs/llncs}

\usepackage[T1]{fontenc}
%\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
%\geometry{a4paper}                   % ... or a4paper or a5paper or ...
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}

%\usepackage{amsfonts}
%\usepackage{fancyhdr}
%\usepackage{cite}
%\usepackage{ifthen}
%\usepackage{amssymb}
%\usepackage{fancyhdr}
%\usepackage{pifont}
\usepackage{stmaryrd}
\usepackage{mathtools,mathpartir}
\usepackage{proof}
%\usepackage{setspace}
%\usepackage{indentfirst}
\usepackage{amsmath,amssymb,amscd,mathrsfs}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\usepackage{epsfig,color,subfigure,enumitem}
\newcommand{\TODO}[1]{\textcolor{red}{\textbf{[TODO:#1]}}}
\newcommand{\NOTE}[1]{\textcolor{blue}{\textbf{[NOTE:#1]}}}
\newcommand{\ERIC}[1]{\textcolor{blue}{#1}}
\newcommand{\coloncolon}{{:\hspace{-.2ex}:}}
\makeatletter
\newcommand{\raisemath}[1]{\mathpalette{\raisem@th{#1}}}
\newcommand{\raisem@th}[3]{\raisebox{#1}{$#2#3$}}
\makeatother

\usepackage{macrospNets}

\def\AlgT{\mathcal{T}}
\def\AlgE{\mathcal{E}}
\def\AlgA{\mathcal{A}}
\def\AlgAS{\mathcal{A}_S}
\def\AlgB{\mathcal{B}}
\def\AlgI{\mathcal{I}}

\newcommand{\Pred}{\symb{Pred}}
\newcommand{\Post}{\symb{Post}}
%\usepackage[math]{cellspace}
%\setlength\cellspacetoplimit{ 37pt}
%\setlength\cellspacebottomlimit{18pt}

\pagestyle{plain}

% addition to the mathpartir package for red dotted rules,
% that we use for open-transitions

\makeatletter
\def \dotover {\textcolor{red}{\leavevmode\cleaders\hb@xt@ .22em{\hss $\cdot$\hss}\hfill\kern\z@}}
\def \reddottedrule #1#2{\hbox {\advance \hsize by -0.5em
%\sbox0{$\genfrac{}{}{0pt}{0}{#1}{#2}$} \phantom{\copy0} %
 {\ooalign{\vphantom{$\genfrac{}{}{0pt}{0}{#1}{#2}$}\cr\dotover\cr$\genfrac{}{}{0pt}{0}{#1}{#2}$\cr}}}}

 \def \dottedrule #1#2 {
  {\sbox0{$\genfrac{}{}{0pt}{0}{#1}{#2}$}%
    \vphantom{\copy0}%
    \ooalign{%
      \hidewidth
      $\vcenter{\moveright\nulldelimiterspace
        \hbox to\wd0{%
         \xleaders\hbox{\kern.5pt\vrule height 0.4pt width 1.5pt\kern.5pt}\hfill
          \kern-1.5pt
        }%
      }$
      \hidewidth\cr
    \box0\cr}}
}

\let \defaultfraction \mpr@@fraction
\makeatother

%\newtheorem{theorem}{Theorem}[section]
\newtheorem{prop}[theorem]{Proposition}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{alg}[theorem]{Algorithm}
%\newtheorem{remark}[theorem]{Remark}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{example}[theorem]{Example}
%\newtheorem{problem}[theorem]{Problem}
%\newtheorem{proof}[theorem]{Proof}

% Macros for the SOS rules and proof trees:
%\newcommand\openrule[2]{\redinfer{#1}{#2}}
\newcommand\openrule[2]{\inferrule*[myfraction=\reddottedrule,center]{#1}{#2}}
%\newcommand\openrule[2]{\inferrule*{#1}{#2}}
%\newcommand\ostate[1]{\triangleleft{\;#1\;}\triangleright}
\newcommand\ostate[1]{\triangleleft{#1}\triangleright}
\newcommand{\sm}[1]{\mbox{\boldmath\small #1}}
\usepackage{algorithm} 
\usepackage{algorithmicx} 
\usepackage{algpseudocode}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\begin{document}

\begin{algorithm}
\caption{Operational Semantics Generation Algorithm of Open pNets} 
\begin{algorithmic}[1]

\Require 
\Ensure 

\State \Return

\end{algorithmic} 
\end{algorithm}

%Combining is to generate all the possible matchings of the subnets' OTs (open transitions). The result list of the matched tuples called *combination*.
% 1. Initialize the result list of OT tuples.
% 2. Get one list of OTs. It's same as get OTs of one subnet.
% 3. Add *null* into the list, it means this subnet does not work this time.
% 4. Combine the rest subnets' OTs. Get the combination of the rest OTs.
% 5. If there are OTs of the chosen list not be chosen, choose one OT.
%      1. If there are tuples of the combination not be chosen, choose one tuple.
%          1. Add the chosen OT into the tuple.
%          2. Add the tuple into the result list, then do the recursion.
% 6. Return the result list.
\begin{algorithm}
\caption{Combining}
\begin{algorithmic}[1]

\Require List $TR$ of result open transition lists from the subnets. 
\Ensure All the possible combinations of open transitions.
\State Initial an empty combination list $C$;
\State Extract a list of open transitions $L$ from $TR$;
\State Insert $null$ into $L$;
\State Get the combinations $C'$ of the $TR$;
\For{each $ot \in L$}
	\For{each $tuple \in C'$}
		\State Add $ot$ into $tuple$;
		\State Add $tuple$ into $C$;
	\EndFor
\EndFor 
\State \Return $C$;

\end{algorithmic}  
\end{algorithm}

% Mixing is to match the combination of the subnets' open transitions, hole behaviors and result action with the SV (synchronization vector) to generate the possible predicates of the OT (open transition). At the same time, other parameters of the OT (global state, subnets' transitions, result action...) are also generated. Then the possible OTs of the pNet can be achieved. 
% 1. Initialize the combination through the method *combineOpenTransitions( )*.
% 2. Initialize the result list.
% 3. Get the number of subnets and holes. They are used to decide how many element of the SV should be matched with them.
% 4. For all tuples of the combination.
%      1. Invoke the *clone( )* method to generate the fresh SV.
%      2. Match the elements of the tuple with the elements of the SV. If there is a *null* matched with a *not null* action, filter this matching. Add the result expression and the predicate of the subnets into the predicate. Generate the target global state correspondingly.
%      3. Match the hole behaviors with the elements of the SV. The hole behavior could be *null*. Add the result expression into the predicate.
%      4. Match the result action with the result action of SV. Add the result expression into the predicate.
%      5. Add the predicate into the OT. Store the OT in the result list.  
% 5. Return the result list of all the possible OTs.
\begin{algorithm}
\caption{Matching}
\begin{algorithmic}[1]

\Require 
\Ensure 

\State \Return

\end{algorithmic} 
\end{algorithm}

\end{document}

\begin{document}

\begin{alg}[Operational Semantics Generation Algorithm of Open pNets]
Open transitions satisfying two rules:
The rule for pLTSs (Tr1) and the rule deal with pNet nodes (Tr2).
Tr2 uses Tr1 and Tr2 recursively if there are subnets of the pNet.
So the structure of the open transitions and subnets' open transitions is like a deduction tree constructively "prove" the open transition.
To generate the list of possible open transitions for the pNet, we build all the possible deduction trees from the given start global state according to these two rules.

\begin{description}
\item[{Tr1 :}]
\end{description}

1) Get the start state of the pLTS.

2) For all the transitions start with the start state.

       2a) Get the target state of the transition. Generate the target global state according to the target state.
       
       2b) Get the guard of the transition, add it into the predicate of the open transition.
       
       2c) Store the generated open transition in the open transition list.

\begin{description}
\item[{Tr2 :}]
\end{description}

It is more complicated, the synchronization vector need to be cloned, the variable actions need a fresh variable, and it need deal with the parameters come from the subnet.

1) Initialize three counters for the subnet, hole behavior, result action and SV.

2) Judge the type of all the subnets of the pNet.
	\begin{itemize}

        \item If it is a pLTS, use the Tr1 recursively, store the open transitions list of the pLTS in the list of keeping subnets' open transitions.
       
        \item If it is a hole, generate a new hole behavior for the open transition. 
           2a) Count the number. The hole behavior counter increases one.
           
           2b) Build a fresh hole behavior.
           
           2c) Generate the hole behavior. Store it in the hole behaviors list of the open transition.
           
        \item If it is a pNet, use the Tr2 recursively, store the open transitions list of the subnet in the list of keeping subnets' open transitions.
       
	\end{itemize}

 3) Generate a new result action for the open transition.
 
       3a) Count the number. The result action counter increases one.
       
       3b) Build a fresh result action.
       
 4) For all SVs of the pNet.
 
       4a) Match result action and the combination of the subnets' open transitions and hole behaviors with the SV to generate the predicates of the open transition. Then a possible open transition of the pNet is generated. Every time the SV is chosen it need be cloned and the cloned one is used for matching.  Similarly, the variable elements of the combination are also need fresh variables.
           
       4b) Store the open transition of the pNet in the open transition list.
       
\end{alg}

In addition, the format of fresh variable (renaming) is already defined as
$$\emph{prefix : tree\ index:counter}$$
\begin{itemize}
   \item[$\bullet$] $prefix$ is the name of variable action composed with an internal name. So far the internal name can be  sva (SV action), ra (result action), hb (hole behavior).
   \item[$\bullet$] $tree index$ is the index of the node in the tree-like structure of the pNet.
   \item[$\bullet$] $counter$ is the current value of the corresponding counter.
\end{itemize}

\end{document}
