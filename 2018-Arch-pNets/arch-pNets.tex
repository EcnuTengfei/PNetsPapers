% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{llncsdoc}

%\usepackage{a4wide}

\usepackage{graphicx}
\usepackage{verbatim}


\let\proof\relax   
\let\endproof\relax

\usepackage{amsmath,amsthm,amscd}
\usepackage{amssymb}  %for blackboard B
\usepackage{rotating} %to rotate the figures
\usepackage{mathpartir} % math paragraph + inference rules
\usepackage{caption}
\usepackage{xifthen}
\usepackage{stmaryrd} % double brackets (\llbracket, \rrbracket)

%% \usepackage[justification=centering,belowskip=-10pt,aboveskip=0pt]{caption}
%% \setlength{\intextsep}{10pt plus 2pt minus 2pt}
%% \setlength\abovedisplayskip{0pt}

\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{hyperref}

\usepackage{soul}
\usepackage[colorinlistoftodos,bordercolor=white]{todonotes}
%% \usepackage[disable,colorinlistoftodos,bordercolor=white]{todonotes}

\newcommand{\Simon}{\\\hfill\mdash Simon}

\newcommand{\noteSB}[2][color=green!40, size=\tiny]{\todo[#1]{{#2}\Simon}}
\newcommand{\noteSBin}[2][inline,color=green!40]{\todo[#1]{{#2}\Simon}}
\newcommand{\todoSB}[2][color=green!40, size=\tiny]{\todo[#1]{\textbf{To-do Simon:} {#2}}}
\newcommand{\todoSBin}[2][inline,color=green!40]{\todo[#1]{\textbf{To-do Simon: } {#2}}}

\newcommand{\defn}[1]{Def.~\ref{defn:#1}}
\newcommand{\defntwo}[2]{Defs~\ref{defn:#1} and \ref{defn:#2}}
\newcommand{\fig}[1]{Fig.~\ref{fig:#1}}
\newcommand{\figs}[2]{Fig.~\ref{fig:#1} and~\ref{fig:#2}}
\newcommand{\tab}[1]{Tab.~\ref{tab:#1}}
\newcommand{\eq}[1]{(\ref{eq:#1})}
\newcommand{\res}[1]{(\ref{res:#1})}
\newcommand{\ex}[1]{Ex.~\ref{ex:#1}}
\newcommand{\exs}[2]{Ex.~\ref{ex:#1} and~\ref{ex:#2}}
\newcommand{\secn}[1]{Sect.~\ref{secn:#1}}
\newcommand{\rem}[1]{Rem.~\ref{rem:#1}}
\newcommand{\lem}[1]{Lem.~\ref{lem:#1}}
\newcommand{\cor}[1]{Cor.~\ref{cor:#1}}
\newcommand{\thm}[1]{Th.~\ref{thm:#1}}
\newcommand{\axs}[1]{Ax.~\ref{ax:#1}}
% \newcommand{\ax}[2]{\ref{ax:#1}.\ref{ax:#1:#2}}
\newcommand{\ax}[1]{Ax.~\ref{ax:#1}}
\newcommand{\prop}[1]{Prop.~\ref{prop:#1}}
\newcommand{\alg}[1]{Alg.~\ref{alg:#1}}
\newcommand{\asmp}[1]{Ass.~\ref{asmp:#1}}

% %%%%%%%%%%%%%%%%%%%%%

\newcommand{\cA}{\ensuremath{\mathcal{A}}}
\newcommand{\bB}{\ensuremath{\mathbf{B}}}
\newcommand{\cB}{\ensuremath{\mathcal{B}}}
\newcommand{\sB}{\ensuremath{\mathbb{B}}}
\newcommand{\cC}{\ensuremath{\mathcal{C}}}
\newcommand{\sC}{\ensuremath{\mathbb{C}}}
\newcommand{\cD}{\ensuremath{\mathcal{D}}}
\newcommand{\fD}{\ensuremath{\mathsf{D}}}
\newcommand{\sD}{\ensuremath{\mathbb{D}}}
\newcommand{\cE}{\ensuremath{\mathcal{E}}}
\newcommand{\sE}{\ensuremath{\mathbb{E}}}
\newcommand{\cF}{\ensuremath{\mathcal{F}}}
\newcommand{\cG}{\ensuremath{\mathcal{G}}}
\newcommand{\cH}{\ensuremath{\mathcal{H}}}
\newcommand{\cI}{\ensuremath{\mathcal{I}}}
\newcommand{\sI}{\ensuremath{\mathbb{I}}}
\newcommand{\cM}{\ensuremath{\mathcal{M}}}
\newcommand{\cN}{\ensuremath{\mathcal{N}}}
\newcommand{\sN}{\ensuremath{\mathbb{N}}}
\newcommand{\cP}{\ensuremath{\mathcal{P}}}
\newcommand{\sP}{\ensuremath{\mathbb{P}}}
\newcommand{\cQ}{\ensuremath{\mathcal{Q}}}
\newcommand{\sQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\cR}{\ensuremath{\mathcal{R}}}
\newcommand{\sR}{\ensuremath{\mathbb{R}}}
\newcommand{\cS}{\ensuremath{\mathcal{S}}}
\newcommand{\sS}{\ensuremath{\mathfrak{S}}}
\newcommand{\cT}{\ensuremath{\mathcal{T}}}
\newcommand{\fT}{\ensuremath{\mathsf{T}}}
\newcommand{\sT}{\ensuremath{\mathbb{T}}}
\newcommand{\cV}{\ensuremath{\mathcal{V}}}
\newcommand{\fV}{\ensuremath{\mathsf{V}}}
\newcommand{\sV}{\ensuremath{\mathbb{V}}}
\newcommand{\sZ}{\ensuremath{\mathbb{Z}}}

\newcommand{\mdash}[1][]{---#1}
\newcommand{\ndash}{--}
\newcommand{\ie}[1][\ ]{i.e.#1}
\newcommand{\etc}[1][\ ]{etc.#1}
\newcommand{\eg}[1][\ ]{e.g.#1}
\newcommand{\cf}[1][\ ]{cf.#1}
\newcommand{\wrt}[1][\ ]{w.r.t.#1}

\newcommand{\bydef}[1]{\ensuremath{\stackrel{\mathit{\scriptscriptstyle def}}{#1}}}
\newcommand{\suchthat}{\ensuremath{\,|\,}}
\newcommand{\rightsuchthat}{\ensuremath{\,\right|\,}}
\newcommand{\leftsuchthat}{\ensuremath{\,\left|\,}}
\newcommand{\setdef}[2]{\ensuremath{\{{#1}\,|\,{#2}\}}}
\newcommand{\setdefb}[2]{\ensuremath{\bigl\{{#1}\,\bigl|\,{#2}\bigr.\bigr\}}}
\newcommand{\Setdef}[2]{\ensuremath{\Big\{{#1}\,\Big|\,{#2}\Big\}}}
\newcommand{\goesto}[2][]{\ensuremath{\xrightarrow[#1]{#2}}}
\newcommand{\notgoesto}[2][]{\ensuremath{\not\xrightarrow[#1]{\ \,#2}}}
\newcommand{\non}[1]{\ensuremath{\overline{#1}}}

\newcommand{\true} {\ensuremath{\mathtt{t\!t}}}
\newcommand{\false}{\ensuremath{\mathtt{f\!f}}}
\newcommand{\noop} {\ensuremath{\mathsf{skip}}}

\newcommand{\data}{\ensuremath{\sD}}
\newcommand{\guards}[1]{\ensuremath{\sB_{#1}}}
\newcommand{\exprs}[1]{\ensuremath{\sE_{#1}}}
\newcommand{\valuations}[1]{\ensuremath{\sV_{#1}}}
\newcommand{\val}[3][]{%
  \ensuremath{\sigma^{#2}_{#3}%
    \ifthenelse{\isempty{#1}}{}{(#1)}%
  }%
}
%% \DeclareMathOperator{\supp}{supp}
\newcommand{\supp}[1]{\ensuremath{\mathrm{supp}(#1)}}
\newcommand{\semopen}[1]{\ensuremath{[{#1}]}}
\newcommand{\semclosed}[1]{\ensuremath{\llbracket{#1}\rrbracket}}
\newcommand{\reachable}[1]{\ensuremath{\mathit{reachable}({#1})}}
\newcommand{\IMextend}[2]{\ensuremath{#1 \ltimes #2}}

% %%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,shapes,automata,petri}
  \tikzset{
  place/.style={
    circle,
    thick,
    draw=blue!75,
    fill=blue!20,
    minimum size=6mm
  },
  transition/.style={
    rectangle,
    thick,
    fill=black,
    minimum width=8mm,
    inner ysep=2pt
    },
    arc/.style = {
      decoration=
      {markings,mark=at position #1 with {circle;}
      },
      postaction={decorate,draw}},
  }   

\let\llncssubparagraph\subparagraph
\let\subparagraph\llncssubparagraph

\begin{document}
\graphicspath{{figures/}}

\title{Architectures and Open pNets}

\author{%
Simon~Bliudze\inst{1}
\and
Ludovic~Henrio\inst{2}
\and
Eric~Madelaine\inst{3}
\and
...
}

\institute{%
  INRIA Lille -- Nord Europe, Villeneuve d'Ascq, France\\
  \email{simon.bliudze@inria.fr}
\and
\and
}


\maketitle

\begin{abstract}
  We extend the theory of architectures with a general
  mechanism for handling various types of data transfer.  We
  encode this extended model into the open pNet semantic
  model and show how this encoding can be used to verify
  that an architecture does, indeed, enforce its
  characteristic property.

\keywords{}
\end{abstract}

%***********************************************************
%***********************************************************

\section{Introduction}
\label{secn:introduction}

%***********************************************************
%***********************************************************

\section{The theory of architectures with data}
\label{secn:archs}

%***********************************************************

\subsection{Components and composition}
\label{sec:components}

\todoSBin{Preliminaries on the universal(?) data domain $\data$
  and valuations.}

\begin{definition}[Components]
  \label{defn:component}
  A \emph{component} is a tuple $(Q, q^0, P, V, \val{0}{},
  \goesto{})$, where
  \begin{itemize}
  \item $Q$ is a set of \emph{states}, with $q^0 \in Q$ the
    \emph{initial state}, 
  \item $P$ is a set of \emph{ports},
  \item $V$ is a set of \emph{component variables},
  \item $\val{0}{} : V \rightarrow \data$ is an \emph{initial
    valuation} of the component variables, 
  \item $\goesto{}\, \subseteq
    Q \times 2^P \times \guards{V} \times \exprs{V} \times Q$
%
    is a \emph{transition relation}, with transitions
    labelled by triples consisting of an \emph{interaction}
    $a \subseteq P$, a Boolean \emph{guard} $g \in
    \guards{V}$ and an \emph{update expression} $e \in
    \exprs{V}$.
  \end{itemize}
%
  We call the pair of sets $(P,V)$ the \emph{interface} of the
  component.\,\footnote{%
%
  In practice, component variables are split in two sub-sets:
  local and exported variables.  Only exported variables belong
  to the component interface and can be used for the interactions
  with other components (see \defn{im}).  However, in the context
  of this paper we can simplify by omitting this separation.
%
  }
%
  Notations $q \goesto{a} q'$, $q \goesto{a}$ and $q
  \notgoesto{a}$ are as usual; for a component $B$, we denote
  $Q_B$, $q^0_B$, $P_B$, $V_B$, $\val{0}{B}$ and $\goesto[B]{}$
  the constituents of $B$.
\end{definition}

\begin{definition}[Component semantics]
  \label{defn:comp:semantics}
  The \emph{open semantics} of a component $B = (Q, q^0, P, V,
  \val{0}{}, \goesto{})$ is given by the LTS $\semopen{B} = (S,
  s^0, \goesto{})$, where $S = Q \times \valuations{V}$, $s^0 =
  (q^0, \val{0}{})$ and $\goesto{}$ is the minimal transition
  relation satisfying the following rule:
  %
  \begin{equation}
    \label{eq:comp:semantics}
    \infer{
      q \goesto{a, g, e} q'
      \and
      v \models g
      \and
      v' = v[e]
    }{
      (q, v) \goesto{a} (q', v')
    }
    \,.
  \end{equation}
  The \emph{closed semantics} of $B$ is given by the LTS
  $\semclosed{B} \bydef{=}\reachable{\semopen{B}}$, comprising
  only the reachable states of $\semopen{B}$.
\end{definition}

\begin{definition}[Interaction model \& composition]
  \label{defn:im}
  Let $\cB = \{B_1,\dots,B_n\}$ be a finite set of
  components with $B_i = (Q_i, q^0_i, P_i, V_i, \val{0}{i},
  \goesto{})$,\footnote{%
%
    Here and below, we skip the index on the transition
    relation $\goesto{}$, since it is always clear from the
    context.
%
} such that all their respective components (\ie $Q_i$, $P_i$,
  and $V_i$) are pairwise disjoint, \ie $\forall i \neq j,\ Q_i
  \cap Q_j = P_i \cap P_j = V_i \cap V_j = \emptyset$.  Let $P =
  \bigcup_{i = 1}^n P_i$ and $V = \bigcup_{i = 1}^n V_i$.

  An \emph{interaction model over $(P,V)$} is a set $\Gamma
  \subseteq 2^P \times \guards{V} \times \exprs{V}$, such that,
  for any $(a, g, e) \in \Gamma$, the guard and update expression
  associated to the \emph{interaction} $a$ satisfy, respectively,
  $g \in \guards{V_a}$ and $e \in \exprs{V_a}$, with $V_a
  \bydef{=} \bigcup_{i:\, a \cap P_i \neq \emptyset} V_i$.  We
  denote $\supp{a} \bydef{=} \setdef{i \in [1,n]}{a \cap P_i \neq
    \emptyset}$ the \emph{support} of the interaction $a$.
  %% We call the set of ports $P$ the \emph{domain} of the
  %% interaction model.

  The \emph{composition of $\cB$ with the interaction model
    $\Gamma$} is the component $\Gamma(\cB) = (Q, q^0, P, V,
  \val{0}, \goesto{})$, where $Q = \prod_{i=1}^n Q_i$, $q^0 =
  q_1^0\dots q_n^0$, $\val{0}{}: V \rightarrow \data$ is such
  that, for any $v \in V_i$, $\val[v]{0}{} = \val[v]{0}{i}$, and
  $\goesto{}$ is the minimal transition relation satisfying
  following rules:
%
  \begin{mathpar}
    \infer{
      q_i \goesto{\emptyset, \true, \noop} q_i'
    }{
      q_1 \dots q_i \dots q_n \goesto{\emptyset, \true, \noop} q_1 \dots q_i' \dots q_n
    }\,,
    
    \infer{    
      (a, g, e) \in \Gamma
      \and
      \forall i \in \supp{a}, q_i \goesto{a \cap P_i, g_i, e_i} q_i'
      \and
      \forall i \not\in \supp{a}, q_i = q_i'
      \\\\
      G = g \land \bigwedge_{i \in \supp{a}} g_i
      \and
      E = e; (e_i)_{i \in \supp{a}}
    }{
      q_1\dots q_n \goesto{a, G, E} q_1'\dots q_n'
    }\,.
  \end{mathpar}
\end{definition}

Below, when speaking of a set of components $\cB$, we will always
assume that it satisfies all the assumptions of \defn{im}.
%
For an interaction $a$, we will abuse the notation by writing
$\supp{a}$ to also denote the set $\setdef{B \in \cB}{a \cap P_B
  \neq \emptyset}$.  The precise meaning of this notation will
always be clear from the context.

%***********************************************************
\subsection{Architectures}
\label{secn:archi}

\begin{definition}[Architecture]
  \label{defn:arch}
  An \emph{architecture} is a tuple $A = (\cC, P_A, V_A, \Gamma)$,
  where $\cC$ is a finite set of \emph{coordinating components}
  with pairwise disjoint sets of ports and variables, such that
  $\bigcup_{C \in \cC} P_C \subseteq P_A$ and
  $\bigcup_{C \in \cC} V_C \subseteq V_A$, and
  $\Gamma \subseteq 2^{P_A} \times \guards{V_A} \times \exprs{V_A}$
  is an interaction model over $(P_A, V_A)$.
\end{definition}

\begin{definition}[Application of an architecture]
  \label{defn:arch:application}
  Let $A = (\cC, P_A, V_A, \Gamma)$ be an architecture and let $\cB$
  be a set of components, such that
%
  \begin{align}
    \bigcup_{B \in \cB} P_B \cap \bigcup_{C \in \cC} P_C = \emptyset\,,
    &&
    P_A \subseteq P \bydef{=} \bigcup_{B \in \cB \cup \cC} P_B\,,
    \\
    \bigcup_{B \in \cB} V_B \cap \bigcup_{C \in \cC} V_C = \emptyset\,,
    &&
    V_A \subseteq V \bydef{=} \bigcup_{B \in \cB \cup \cC} V_B\,,
  \end{align}
%
  and, denoting, for any $(a, g, e) \in \Gamma$, $V_a \bydef{=}
  \bigcup_{B \in \supp{a}} V_B$, we have $g \in \guards{V_a}$ and
  $e \in \exprs{V_a}$.
%
  The \emph{application of the architecture $A$ to the set of
  components $\cB$} is the component $ A(\cB) \bydef{=}
  (\IMextend{\Gamma}{P})(\cC \cup \cB)$, where
%
  \begin{equation}
    \label{eq:im:extension}
    \IMextend{\Gamma}{P} \bydef{=}
    \setdefb{
      (a \cup a', g, e)
    }{
      (a, g, e) \in \Gamma, a' \subseteq P \setminus P_A
    }
  \end{equation}
%
  denotes the \emph{extension} of the interaction model $\Gamma$
  to the set of ports $P$.
\end{definition}

An architecture $A$ enforces coordination constraints on the
components in $\cB$.  The interface $(P_A, V_A)$ of an
architecture $A$ contains all ports of the coordinating
components $\cC$ and some additional ports, which must belong to
the components in $\cB$.  In the application $A(\cB)$, the ports
belonging to $P_A$ can only participate in the interactions
defined by the interaction model $\Gamma$ of $A$.  Ports which do
not belong to $P_A$ are not restricted and can participate in any
interaction.  In particular, they can join the interactions in
$\Gamma$ (see \eq{im:extension}).  If the interface of the
architecture covers all ports of the system, \ie $P = P_A$, we
have $P\setminus P_A = \emptyset$ and the only interactions
allowed in $A(\cB)$ are those belonging to $\Gamma$.  Notice also
that the restrictions imposed by \defn{archi:application} on the
set of operand components $\cB$ ensure that an interaction in
$\IMextend{\Gamma}{P}$ can only refer to variables of the
participating components.
%
Finally, the definition of $\IMextend{\Gamma}{P}$ requires that
an interaction from $\Gamma$ be involved in every interaction
belonging to $\IMextend{\Gamma}{P}$.  To allow the ports from $P
\setminus P_A$ to be fired independently in $A(\cB)$, one must
have $(\emptyset, \true, \noop) \in \Gamma$.  

\begin{definition}[Composition of architectures]
  \label{defn:arch:composition}
  
\end{definition}

%***********************************************************
%***********************************************************

\section{Open pNets}
\label{secn:pNets}

%***********************************************************
%***********************************************************

\section{Encoding of architectures into open pNets}
\label{secn:encoding}

%***********************************************************
%***********************************************************

\section{SMT encoding of open pNets}
\label{secn:smt}

%***********************************************************
%***********************************************************

\section{Case study}
\label{secn:case-study}

%***********************************************************
%***********************************************************

\section{Related work}
\label{secn:related}

%***********************************************************
%***********************************************************

\section{Conclusion}
\label{secn:conclusion}

%***********************************************************
%***********************************************************

\bibliographystyle{abbrv}
\bibliography{}

\end{document}
