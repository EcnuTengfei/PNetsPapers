% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{llncsdoc}

%\usepackage{a4wide}

\usepackage{graphicx}
\usepackage{verbatim}


\let\proof\relax   
\let\endproof\relax

\usepackage{amsmath,amsthm,amscd}
\usepackage{amssymb}    % for blackboard B
\usepackage{rotating}   % to rotate the figures
\usepackage{mathpartir} % math paragraph + inference rules
\usepackage{mathtools}  % for align, multline etc.
\usepackage{caption}
\usepackage{xifthen}
\usepackage{stmaryrd} % double brackets (\llbracket, \rrbracket)

%% \usepackage[justification=centering,belowskip=-10pt,aboveskip=0pt]{caption}
%% \setlength{\intextsep}{10pt plus 2pt minus 2pt}
%% \setlength\abovedisplayskip{0pt}

\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{hyperref}

\usepackage{soul}
\usepackage[colorinlistoftodos,bordercolor=white]{todonotes}
%% \usepackage[disable,colorinlistoftodos,bordercolor=white]{todonotes}
\usepackage{macrospNets}

\newcommand{\Simon}{\\\hfill\mdash Simon}

\newcommand{\noteSB}[2][color=green!40, size=\tiny]{\todo[#1]{{#2}\Simon}}
\newcommand{\noteSBin}[2][inline,color=green!40]{\todo[#1]{{#2}\Simon}}
\newcommand{\todoSB}[2][color=green!40, size=\tiny]{\todo[#1]{\textbf{To-do Simon:} {#2}}}
\newcommand{\todoSBin}[2][inline,color=green!40]{\todo[#1]{\textbf{To-do Simon: } {#2}}}
\newcommand{\Ludo}{\\\hfill\mdash Ludo}
\newcommand{\noteLH}[2][color=blue!40, size=\tiny]{\todo[#1]{{#2}\Ludo}}
\newcommand{\noteLHin}[2][inline,color=blue!40]{\todo[#1]{{#2}\Ludo}}
\newcommand{\todoLH}[2][color=blue!40, size=\tiny]{\todo[#1]{\textbf{To-do Ludo:} {#2}}}
\newcommand{\todoLHin}[2][inline,color=blue!40]{\todo[#1]{\textbf{To-do Ludo: } {#2}}}

\newcommand{\noteIn}[2][inline,color=black!20]{\todo[#1]{{#2}}}

\newcommand{\defn}[1]{Def.~\ref{defn:#1}}
\newcommand{\defntwo}[2]{Defs~\ref{defn:#1} and \ref{defn:#2}}
\newcommand{\fig}[1]{Fig.~\ref{fig:#1}}
\newcommand{\figs}[2]{Fig.~\ref{fig:#1} and~\ref{fig:#2}}
\newcommand{\tab}[1]{Tab.~\ref{tab:#1}}
\newcommand{\eq}[1]{(\ref{eq:#1})}
\newcommand{\res}[1]{(\ref{res:#1})}
\newcommand{\ex}[1]{Ex.~\ref{ex:#1}}
\newcommand{\exs}[2]{Ex.~\ref{ex:#1} and~\ref{ex:#2}}
\newcommand{\secn}[1]{Sect.~\ref{secn:#1}}
\newcommand{\rem}[1]{Rem.~\ref{rem:#1}}
\newcommand{\lem}[1]{Lem.~\ref{lem:#1}}
\newcommand{\cor}[1]{Cor.~\ref{cor:#1}}
\newcommand{\thm}[1]{Th.~\ref{thm:#1}}
\newcommand{\axs}[1]{Ax.~\ref{ax:#1}}
% \newcommand{\ax}[2]{\ref{ax:#1}.\ref{ax:#1:#2}}
\newcommand{\ax}[1]{Ax.~\ref{ax:#1}}
\newcommand{\prop}[1]{Prop.~\ref{prop:#1}}
\newcommand{\alg}[1]{Alg.~\ref{alg:#1}}
\newcommand{\asmp}[1]{Ass.~\ref{asmp:#1}}

% %%%%%%%%%%%%%%%%%%%%%

\newcommand{\cA}{\ensuremath{\mathcal{A}}}
\newcommand{\bB}{\ensuremath{\mathbf{B}}}
\newcommand{\cB}{\ensuremath{\mathcal{B}}}
\newcommand{\sB}{\ensuremath{\mathbb{B}}}
\newcommand{\cC}{\ensuremath{\mathcal{C}}}
\newcommand{\sC}{\ensuremath{\mathbb{C}}}
\newcommand{\cD}{\ensuremath{\mathcal{D}}}
\newcommand{\fD}{\ensuremath{\mathsf{D}}}
\newcommand{\sD}{\ensuremath{\mathbb{D}}}
\newcommand{\cE}{\ensuremath{\mathcal{E}}}
\newcommand{\sE}{\ensuremath{\mathbb{E}}}
\newcommand{\cF}{\ensuremath{\mathcal{F}}}
\newcommand{\cG}{\ensuremath{\mathcal{G}}}
\newcommand{\cH}{\ensuremath{\mathcal{H}}}
\newcommand{\cI}{\ensuremath{\mathcal{I}}}
\newcommand{\sI}{\ensuremath{\mathbb{I}}}
\newcommand{\cM}{\ensuremath{\mathcal{M}}}
\newcommand{\cN}{\ensuremath{\mathcal{N}}}
\newcommand{\sN}{\ensuremath{\mathbb{N}}}
\newcommand{\cP}{\ensuremath{\mathcal{P}}}
\newcommand{\sP}{\ensuremath{\mathbb{P}}}
\newcommand{\cQ}{\ensuremath{\mathcal{Q}}}
\newcommand{\sQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\cR}{\ensuremath{\mathcal{R}}}
\newcommand{\sR}{\ensuremath{\mathbb{R}}}
\newcommand{\cS}{\ensuremath{\mathcal{S}}}
\newcommand{\sS}{\ensuremath{\mathfrak{S}}}
\newcommand{\cT}{\ensuremath{\mathcal{T}}}
\newcommand{\fT}{\ensuremath{\mathsf{T}}}
\newcommand{\sT}{\ensuremath{\mathbb{T}}}
\newcommand{\cV}{\ensuremath{\mathcal{V}}}
\newcommand{\fV}{\ensuremath{\mathsf{V}}}
\newcommand{\sV}{\ensuremath{\mathbb{V}}}
\newcommand{\sZ}{\ensuremath{\mathbb{Z}}}

\newcommand{\mdash}[1][]{---#1}
\newcommand{\ndash}{--}
\newcommand{\ie}[1][\ ]{i.e.#1}
\newcommand{\etc}[1][\ ]{etc.#1}
\newcommand{\eg}[1][\ ]{e.g.#1}
\newcommand{\cf}[1][\ ]{cf.#1}
\newcommand{\wrt}[1][\ ]{w.r.t.#1}
\newcommand{\resp}[1][\ ]{resp.#1}

\newcommand{\bydef}[1]{\ensuremath{\stackrel{\mathit{\scriptscriptstyle def}}{#1}}}
\newcommand{\suchthat}{\ensuremath{\,|\,}}
\newcommand{\rightsuchthat}{\ensuremath{\,\right|\,}}
\newcommand{\leftsuchthat}{\ensuremath{\,\left|\,}}
\newcommand{\setdef}[2]{\ensuremath{\{{#1}\,|\,{#2}\}}}
\newcommand{\setdefb}[2]{\ensuremath{\bigl\{{#1}\,\bigl|\,{#2}\bigr.\bigr\}}}
\newcommand{\Setdef}[2]{\ensuremath{\Big\{{#1}\,\Big|\,{#2}\Big\}}}
\newcommand{\goesto}[2][]{\ensuremath{\xrightarrow[#1]{#2}}}
\newcommand{\notgoesto}[2][]{\ensuremath{\not\xrightarrow[#1]{\ \,#2}}}
\newcommand{\non}[1]{\ensuremath{\overline{#1}}}

\newcommand{\true} {\ensuremath{\mathtt{t\!t}}}
\newcommand{\false}{\ensuremath{\mathtt{f\!f}}}
\newcommand{\noop} {\ensuremath{\emptyset}} % \mathsf{skip}

\newcommand{\data}{\ensuremath{\sD}}
\newcommand{\guards}[1]{\ensuremath{\sB_{#1}}}
\newcommand{\exprs}[1]{\ensuremath{\sE_{#1}}}
\newcommand{\valuations}[1]{\ensuremath{\sV_{#1}}}
\newcommand{\val}[3][]{%
  \ensuremath{#1{\sigma}^{#2}_{#3}}%
}
\newcommand{\primeit}[1]{#1'}
\newcommand{\doubleprimeit}[1]{#1''}

\newcommand{\export}[1][]{\ensuremath{\varepsilon_{#1}}}
\newcommand{\valdiff}[2]{\ensuremath{#1 \triangle #2}}
\newcommand{\supp}[1]{\ensuremath{\mathrm{supp}(#1)}}
\newcommand{\semopen}[1]{\ensuremath{[{#1}]}}
\newcommand{\semclosed}[1]{\ensuremath{\llbracket{#1}\rrbracket}}
\newcommand{\reachable}[1]{\ensuremath{\mathit{reachable}({#1})}}
\newcommand{\IMextend}[2]{\ensuremath{#1 \ltimes #2}}
\newcommand{\arcomp}{\oplus}
\newcommand{\arequiv}{\equiv}
\newcommand{\Arcomp}{\Bigoplus}
\newcommand{\expmix}{\wedge}
\newcommand{\order}{\leqslant}

\makeatletter
\newcommand{\doubletilde}[1]{{%
  \mathpalette\double@tilde{#1}%
}}
\newcommand{\double@tilde}[2]{%
  \sbox\z@{$\m@th#1\tilde{#2}$}%
  \ht\z@=.9\ht\z@
  \tilde{\box\z@}%
}
\makeatother

\newcounter{tempctr}
\newcommand{\breakenumistart}{%
  \setcounter{tempctr}{\value{enumi}}%
  \end{enumerate}%
}
\newcommand{\breakenumiend}{%
  \begin{enumerate}%
  \setcounter{enumi}{\value{tempctr}}%
}

% %%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,shapes,automata,petri}
  \tikzset{
  place/.style={
    circle,
    thick,
    draw=blue!75,
    fill=blue!20,
    minimum size=6mm
  },
  transition/.style={
    rectangle,
    thick,
    fill=black,
    minimum width=8mm,
    inner ysep=2pt
    },
    arc/.style = {
      decoration=
      {markings,mark=at position #1 with {circle;}
      },
      postaction={decorate,draw}},
  }   

\let\llncssubparagraph\subparagraph
\let\subparagraph\llncssubparagraph

\begin{document}
\graphicspath{{figures/}}

\title{Architectures and Open pNets}

\author{%
Simon~Bliudze\inst{1}
\and
Ludovic~Henrio\inst{2}
\and
Eric~Madelaine\inst{3}
\and
...
}

\institute{%
  INRIA Lille -- Nord Europe, Villeneuve d'Ascq, France\\
  \email{simon.bliudze@inria.fr}
\and
\and
}


\maketitle

\begin{abstract}
  We extend the theory of architectures with a general
  mechanism for handling various types of data transfer.  We
  encode this extended model into the open pNet semantic
  model and show how this encoding can be used to verify
  that an architecture does, indeed, enforce its
  characteristic property.

\keywords{}
\end{abstract}

%****************************************************************
%****************************************************************

\section{Introduction}
\label{secn:introduction}

\todoSBin{Preliminaries on the universal(?) data domain $\data$
  and valuations.

For two valuations $\val{1}{}, \val{2}{} : V \rightarrow \data$,
we denote \[\valdiff{\val{1}{}}{\val{2}{}} \bydef{=} \setdefb{v
  \in V}{\val{1}{}(v) \neq \val{2}{}(v)}\] the set of variables
that are assigned different values by the two valuations.

To guarantee preservation of properties guards and expressions
have to be \emph{monotonic}.  In the case of a trivial order, \ie
when nothing is comparable, \emph{any guard or expression is
  monotonic}.  Thus, this is not really a constraint!
}

\subsection*{Unifying notations -- remarks}

\todoLHin{proposed notations:}
$g$ are boolean expressions
$e_i$ are updates/assignments

\todoLHin{Remove term algebra or simplify?}
\todoLHin{universal domain $\implies$ remove sort}
\todoLHin{replace assignments by $e_i$}

\noteIn{In Archi we have $a$, whereas in pNets we have $\alpha$, where, approximately $\alpha = 
a(x_1..x_n)$, except that $a$ is port name in archi and action name in pNets.
Is this true? can we unify better? or is it sufficient?
\Ludo

$a$ is a set of ports, but otherwise, yes, this is true.  I think
this is coherent, since, in archi, we have the ``interaction
part'', \ie only ports, plus the data part, \ie variables,
guards, expressions.  In pNets, these are combined.  So, it seems
ok that notations differ\mdash ``uniformisation'' will be
achieved by encoding archi $\rightarrow$ pNets.  \Simon }

\noteIn{states looks ok, but initial state is $s_0$ in pNet and not in archi : $s^0$.  Exponent 
position was removed from pNet because we found it complex with indexed set notation but 
could be ok.
\Ludo

I am using exponent notation for ``modifiers'', reserving\mdash
as much as possible\mdash index notation for enumeration.  I
think this can be solved, where necessary, by using parentheses,
\eg $(s^0_i)^{i \in I}$
\Simon
}

%****************************************************************
%****************************************************************

\section{The theory of architectures with data}
\label{secn:archs}

%****************************************************************

\subsection{Components and composition}
\label{sec:components}

\begin{definition}[Components]
  \label{defn:component}
  A \emph{component} is a tuple $(Q, q^0, V, \val{0}{}, P,
  \export{}, \goesto{})$, where
  \begin{itemize}
  \item $Q$ is a set of \emph{states}, with $q^0 \in Q$ the
    \emph{initial state}, 
  \item $V$ is a set of \emph{component variables},
  \item $\val{0}{} : V \rightarrow \data$ is an \emph{initial
    valuation} of the component variables, 
  \item $P$ is a set of \emph{ports}, with
    \noteSB{Added this}\hl{$\export : P \rightarrow 2^V$ 
    the \emph{export function},}
  \item $\goesto{}\, \subseteq
    Q \times 2^P \times \guards{V} \times \exprs{V} \times Q$
%
    is a \emph{transition relation}, with transitions
    labelled by triples consisting of an \emph{interaction}
    $\emptyset \neq a \subseteq P$, a Boolean \emph{guard} $g \in
    \guards{V}$ and an \emph{update expression} $e \in
    \exprs{V}$.
  \end{itemize}
%
  We call \noteSB{Maybe rather $(P, \export)$}\hl{the pair of sets $(V,P)$} the \emph{interface} of the
  component.\,\footnote{%
%
  In practice, component variables are split in two sub-sets:
  local and exported variables.  Only exported variables belong
  to the component interface and can be used for the interactions
  with other components (see \defn{im}).  However, in the context
  of this paper we can simplify by omitting this separation.
%
  }
%
  Notations $q \goesto{a} q'$ and $q \goesto{a}$ are as usual;
  for a component $B$, we denote $Q_B$, $q^0_B$, $P_B$, $V_B$ and
  $\val{0}{B}$ the corresponding constituents of $B$.  We will
  skip the index on the transition relations $\goesto{}$, since it
  is always clear from the context.
\end{definition}

\begin{definition}[Component semantics]
  \label{defn:comp:semantics}
  The \emph{open semantics} of a component $B = (Q, q^0, V,
  \val{0}{}, P, \export, \goesto{})$ is given by the LTS $\semopen{B} = (S,
  s^0, \goesto{})$, where $S = Q \times \valuations{V}$, $s^0 =
  (q^0, \val{0}{})$ and $\goesto{}$ is the minimal transition
  relation satisfying the rule
  %
  \begin{equation}
    \label{eq:comp:semantics}
    \infer{
      q \goesto{a, g, e} q'
      \and
      \val{}{} \models g
      \and
      \val[\primeit]{}{} = \tilde{\val{}{}}[e]
      \and
      \valdiff{\val{}{}}{\tilde{\val{}{}}} \subseteq \export(a)
    }{
      (q, \val{}{}) \goesto{a,\tilde{\val{}{}}} (q', \val[\primeit]{}{})
    }
    \,.
  \end{equation}
  %
  \todoSB{Do we actually need this?}
  \hl{The \emph{closed semantics} of $B$ is given by the LTS
  $\semclosed{B} \bydef{=}\reachable{\semopen{B}}$, comprising
  only the reachable states of $\semopen{B}$.}
\end{definition}

The use of the intermediate valuation $\tilde{\val{}{}}$ in the
conclusion and the third premise of rule \eq{comp:semantics}
allows some of the variables to get new values before the
transition is actually fired.  Thus the component is \emph{open}
to the exchange of data with its environment.  However, the
fourth premise in \eq{comp:semantics} restricts the set of
variables, which can be affected by such data transfer, to those
that are exported through the ports participating in the
interaction.

\begin{definition}[Interaction model \& composition]
  \label{defn:im}
  Consider a finite set of components $\cB = (Q_i, q^0_i, V_i,
  \val{0}{i}, P_i, \export[i], \goesto{})^{i \in I}$, such that
  all their respective components (\ie $Q_i$, $P_i$, and $V_i$)
  are pairwise disjoint, \ie $\forall i \neq j,\ Q_i \cap Q_j =
  P_i \cap P_j = V_i \cap V_j = \emptyset$.  Let $P = \bigcup_{i
  \in I} P_i$ and $V = \bigcup_{i \in I} V_i$.
%
  For a set of ports $a \subseteq P$, we denote $\supp{a}
  \bydef{=} \setdef{i \in I}{a \cap P_i \neq \emptyset}$ the
  \emph{support} of $a$,
  \noteSB{Updated this}\hl{and $V_a \bydef{=} \bigcup_{i \in
    \supp{a}} \export[i](a \cap P_i)$ the set of component
  variables exported for $a$.}

  An \emph{interaction model over \hl{$(V,P)$}} is a set $\Gamma
  \subseteq 2^P \times \guards{V} \times \exprs{V}$, such that,
  for any $(a, g, e) \in \Gamma$, the guard and update expression
  associated to the \emph{interaction} $a$ satisfy, respectively,
  $g \in \guards{V_a}$ and $e \in \exprs{V_a}$.\footnote{%
%
    Notice that this definition allows $(\emptyset, \true,
    \noop)$ and $(\emptyset, \false, \noop)$ to be included in
    $\Gamma$.
%
  }
  %% We call the set of ports $P$ the \emph{domain} of the
  %% interaction model.

  The \emph{composition of $\cB$ with the interaction model
    $\Gamma$} is the component
  $\Gamma(\cB) = (Q, q^0, V, \val{0}{}, P, \export, \goesto{})$,
  where
%
  $Q = \prod_{i \in I} Q_i$;
%
  $q^0 = (q_i^0)^{i \in I}$;
%
  $\val{0}{}: V \rightarrow \data$ is such that, for any $v \in
  V_i$, $\val{0}{}(v) = \val{0}{i}(v)$;
%
  $\export : P \rightarrow 2^V$ is such that, for any $p \in
  P_i$, $\export(p) = \export[i](p)$;
%
  and $\goesto{}$ is the minimal transition relation satisfying
  the rule
%
  \begin{gather}
%%     \label{eq:im:empty}
%%     \infer{
%%       q_j \goesto{\emptyset, g, e} q_j'
%%       \and
%%       \forall i \neq j, q_i = q_i'
%%     }{
%%       (q_i)^{i \in I} \goesto{\emptyset, g, e} (q_i')^{i \in I}
%%     }\,,
%% %
%%     \\[0.5\baselineskip]
    \label{eq:im:int}
%
    \infer{    
      (a, g, e) \in \Gamma
      \and
      a \neq \emptyset
      \and
      \forall i \in \supp{a}, q_i \goesto{a \cap P_i, g_i, e_i} q_i'
      \and
      \forall i \not\in \supp{a}, q_i = q_i'
%
      \\\\
      \textstyle
%
      G = g \land \bigwedge_{i \in \supp{a}} g_i
      \and
      E = e; e_i^{i \in \supp{a}}
    }{
      (q_i)^{i \in I} \goesto{a, G, E} (q_i')^{i \in I}
    }\,.
  \end{gather}
\end{definition}

Below, when speaking of a set of components $\cB$, we will always
assume that it satisfies all the assumptions of \defn{im}.
%
For an interaction $a$, we will abuse the notation by writing
$\supp{a}$ to also denote the set $\setdef{B \in \cB}{a \cap P_B
  \neq \emptyset}$.  The precise meaning of this notation will
always be clear from the context.

%****************************************************************
\subsection{Architectures}
\label{secn:archi}

\begin{definition}[Architecture]
  \label{defn:arch}
  An \emph{architecture} is a tuple $A = (\cC, V_A, P_A, \Gamma)$,
  where $\cC$ is a finite set of \emph{coordinating components}
  with pairwise disjoint sets of ports and variables, such that
  $\bigcup_{C \in \cC} P_C \subseteq P_A$ and
  $\bigcup_{C \in \cC} V_C \subseteq V_A$, and
  $\Gamma \subseteq 2^{P_A} \times \guards{V_A} \times \exprs{V_A}$
  is an interaction model over \hl{$(V_A, P_A)$}.
\end{definition}

\begin{definition}[Application of an architecture]
  \label{defn:arch:application}
  Let $A = (\cC, V_A, P_A, \Gamma)$ be an architecture and let $\cB$
  be a set of components, such that
%
  \begin{align}
    \bigcup_{B \in \cB} V_B \cap \bigcup_{C \in \cC} V_C = \emptyset\,,
    &&
    V_A \subseteq V \bydef{=} \bigcup_{B \in \cB \cup \cC} V_B\,,
    \\
    \bigcup_{B \in \cB} P_B \cap \bigcup_{C \in \cC} P_C = \emptyset\,,
    &&
    P_A \subseteq P \bydef{=} \bigcup_{B \in \cB \cup \cC} P_B\,,
  \end{align}
%
  and
  %% , denoting, for any $(a, g, e) \in \Gamma$, $V_a \bydef{=}
  %% \bigcup_{B \in \supp{a}} \export[B](a \cap P_B)$, we have
  $g \in \guards{V_a}$ and
  $e \in \exprs{V_a}$ (see \defn{im} for the notation $V_a$).
%
  The \emph{application of the architecture $A$ to the set of
  components $\cB$} is the component $ A(\cB) \bydef{=}
  (\IMextend{\Gamma}{P})(\cC \cup \cB)$, where
%
  \begin{equation}
    \label{eq:im:extension}
    \IMextend{\Gamma}{P} \bydef{=}
    \setdefb{
      (a \cup a', g, e)
    }{
      (a, g, e) \in \Gamma, a' \subseteq P \setminus P_A
    }
  \end{equation}
%
  denotes the \emph{extension} of the interaction model $\Gamma$
  to the set of ports $P$.
\end{definition}

\todoSBin{Define equivalence $\arequiv$?}

An architecture $A$ enforces coordination constraints on the
components in $\cB$.  The interface \hl{$(V_A, P_A)$} of an
architecture $A$ contains all ports of the coordinating
components $\cC$ and some additional ports, which must belong to
the components in $\cB$.  In the application $A(\cB)$, the ports
belonging to $P_A$ can only participate in the interactions
defined by the interaction model $\Gamma$ of $A$.  Ports which do
not belong to $P_A$ are not restricted and can participate in any
interaction.  In particular, they can join the interactions in
$\Gamma$ (see \eq{im:extension}).  If the interface of the
architecture covers all ports of the system, \ie $P = P_A$, we
have $P\setminus P_A = \emptyset$ and the only interactions
allowed in $A(\cB)$ are those belonging to $\Gamma$.  Notice also
that the restrictions imposed by \defn{arch:application} on the
set of operand components $\cB$ ensure that an interaction in
$\IMextend{\Gamma}{P}$ can only refer to variables of the
participating components.
%
Finally, the definition of $\IMextend{\Gamma}{P}$ requires that
an interaction from $\Gamma$ be involved in every interaction
belonging to $\IMextend{\Gamma}{P}$.  To allow the ports from $P
\setminus P_A$ to be fired independently in $A(\cB)$, one must
have $(\emptyset, \true, \noop) \in \Gamma$.  

\begin{definition}[Composition of architectures]
  \label{defn:arch:composition}
  Let $A_i = (\cC_i, V_{A_i}, P_{A_i}, \Gamma_i)$, for $i = 1,2$,
  be two architectures.  The \emph{composition} of $A_1$ and
  $A_2$ is the architecture $A_1 \arcomp A_2 = (\cC_1 \cup \cC_2,
  V_{A_1} \cup V_{A_2}, P_{A_1} \cup P_{A_2}, \Gamma)$, where
%
  \begin{equation}
    \label{eq:arch:composition}
    \Gamma = \setdefb{
      (a, g_1 \land g_2, e_1 \expmix e_2) 
    }{
      (a \cap P_{A_i}, g_i, e_i) \in \Gamma_i,
      \text{ for } i = 1,2
    }
    \,.
  \end{equation}
\end{definition}

\begin{proposition}[Properties of $\arcomp$]
  \label{prop:arcomp:nice}
  Architecture composition $\arcomp$ is commutative and
  associative; it is idempotent if all coordinating components
  are deterministic; $A_{id} = \bigl(\emptyset, \emptyset,
  \emptyset, \{\emptyset\}\bigr)$ is its neutral element, \ie for
  any architecture $A$, we have $A \oplus A_{id} \arequiv A$.
  Furthermore, for any component $B$, we have $A_{id}(B) = B$.
\end{proposition}
%
\begin{proof}[Sketch of the proof]
  Commutativity and associativity follow from the corresponding
  properties of set union, Boolean conjunction and
  \todoSB{Check ``semi''}\hl{semilattice meet}.
%
  Suppose we have two architectures $A = A'$.  This does not
  necessarily mean that their sets of coordinating components
  coincide.  However, if all the involved coordinating components
  are deterministic, then, in any state of $(A \arcomp A')(\cB)$,
  both architectures will impose the same restrictions, enabling
  the same interactions between the coordinating and operand
  components.  Hence, we have $(A \arcomp A')(\cB) = A(\cB) =
  A'(\cB)$.  Since this holds for any set of components $\cB$, we
  conclude that $A \arcomp A' \arequiv A \arequiv A'$.
%
  The properties of $A_{id}$ follow immediately from the
  definitions of architecture application and composition.
\end{proof}


%****************************************************************
\subsection{Preservation of safety properties}
\label{secn:safety}

For a component $B$, we denote $S_{\semopen{B}}$,
$s^0_{\semopen{B}}$ the corresponding constituents of
$\semopen{B}$.

\begin{definition}[Safety properties]
  \label{defn:property}
  Let $B$ be a component.  A \emph{safety property} (below,
  simply \emph{property}) of $B$ is a state predicate $\Phi:
  S_{\semopen{B}} \rightarrow \sB$, such that $\bigl((q,
  \val{}{}) \models \Phi\bigr) \land (\val[\primeit]{}{} \order
  \val{}{})$ implies $(q, \val[\primeit]{}{}) \models \Phi$,
  where we write $(q, \val{}{}) \models \Phi$ iff $\Phi(q,
  \val{}{}) = \true$.  A property $\Phi$ is \emph{initial} if
  $s^0_{\semopen{B}} \models \Phi$.
  %% \todoSB{Do we need this?}\hl{;
  %% it is \emph{reachable} iff there exists a possibly empty path
  %% $s^0_{\semopen{B}} \goesto{a^1, \val{1}{}} s^1 \goesto{a^2,
  %%   \val{2}{}} \cdots \goesto{a^n, \val{n}{}} s^n$, such that
  %% $s^n \models \Phi$}.
\end{definition}

\todoSB{Cite the original paper somewhere.}
The main idea of our approach is that an architecture enforces
its characteristic property on the set of its operand components.
From this point of view, the set of coordinating components is
not relevant, neither are their states.  Thus, to talk about
properties enforced by architectures, we consider properties on
the unrestricted composition of the operand components as
formalized by the following definition.

\begin{definition}[Enforcing properties]
  \label{defn:impose}
  Let $A = (\cC, P_A, V_A, \Gamma)$ be an architecture; let $\cB$
  be a set of components and $\Phi$ an initial property of
  their parallel composition $A_{id}(\cB)$ (see
  \prop{arcomp:nice}).  We say that \emph{$A$ enforces $\Phi$ on
    $\cB$} iff, for every state $s = (s_c, s_b)$ reachable in
  $\semopen{A(\cB)}$, with 
  $s_c \in \prod_{C \in \cC} S_{\semopen{C}}$ and
  $s_b \in \prod_{B \in \cB} S_{\semopen{B}}$,
  we have $s_b \models \Phi$.
\end{definition}

According to the above definition, when we say that an
architecture enforces some property $\Phi$, it is implicitly
assumed that $\Phi$ is initial for the coordinated components.
Below, we omit mentioning this explicitly.

\begin{theorem}[Preserving enforced properties]
  \label{thm:combining}
  Let $\cB$ be a set of components; let $A_i = (\cC_i, V_{A_i},
  P_{A_i}, \Gamma_i)$, for $i = 1,2$, be two architectures
  enforcing on $\cB$ the properties $\Phi_1$ and $\Phi_2$
  respectively.  The composition $A_1 \arcomp A_2$ enforces on
  $\cB$ the property $\Phi_1 \land \Phi_2$.
\end{theorem}

%****************************************************************
%****************************************************************

\section{Open pNets}
\label{secn:pNets}
\todoLHin{rewrite after uniformisation}
pNets are tree-like structures, where the leaves are either
\emph{parameterised labelled transition systems (pLTSs)}, expressing the
behaviour of basic processes, or \emph{holes}, used as placeholders
for unknown processes, of which we only specify the set of possible
actions, this set is named the \emph{sort}.
Nodes of the tree (pNet nodes) are synchronising artifacts, using a
set of \emph{synchronisation vectors} that express the possible
synchronisation between the parameterised actions of a subset of the
sub-trees.


%\smallskip\noindent
\paragraph*{Notations.}
We extensively use indexed structures
over some countable indexed sets, which are equivalent to mappings over
the countable set. % . The indexes will usually be
% integers, bounded or not. Such an indexed family is
%denoted
%follows:
$a_i^{i\in I}$
%, or equivalently  $(i\mapsto a_i)^{i\in I}$
denotes a family of elements $a_i$ indexed over the
set $I$. % Such a family
% is equivalent to the mapping $(i\mapsto a_i)^{i\in I}$.
% To specify the set over which the structure is indexed,
% indexed structures are always denoted with an exponent of the form $i\in I$
% (arithmetic only appears in the indexes if necessary).
$a_i^{i\in I}$ defines both $I$ the set over which the family is
indexed (called \emph{range}), and $a_i$ the elements of the family.
E.g., $a^{i\in\{3\}}$ is the mapping with a single entry $a$ at index
$3$ ; abbreviated $(3\mapsto a)$ in the following.
When this is not
ambiguous, we shall use notations for sets, and typically write
``indexed set over I'' when formally we should speak of multisets, and
write $x\in a_i^{i\in I}$ to mean $\exists i\in I.\, x=a_i$.  An empty
family is denoted $\emptyset$. We
denote classically with an overline -- $\overline{a}$  -- a family when the indexing set 
is
not meaningful.  $\uplus$ is the disjoint union on
indexed sets.

\paragraph*{Term algebra.}
Our models rely on a notion of parameterised actions, that are
symbolic expressions using data types and variables. As our model aims
at encoding the low-level behaviour of possibly very different
programming languages, we do not want to impose one specific algebra
for denoting actions, nor any specific communication mechanism. So we
leave unspecified the constructors of the algebra that will allow building
expressions and actions. Moreover, we use a generic {\em action interaction}
mechanism, based on (some sort of) unification between two or more action
expressions, to express various kinds of communication or
synchronisation mechanisms.

\def\Talg{\mathcal{T}_{\Sigma,\P}}
Formally, we assume the existence of a term algebra $\Talg$,
where $\Sigma$ is the signature of the data and action constructors,
and $\P$ a set of variables. Within $\Talg$, we distinguish a set of
data expressions $\mathcal{E}_\P$, including a set of boolean
expressions \todoLHin{$\mathcal{B} \to g$}
$\mathcal{B}_{\P}$ ($\mathcal{B}_{\P}\subseteq\mathcal{E}_\P$).
On top of $\mathcal{E}_\P$ we build the action algebra
$\mathcal{A}_\P$, with $\mathcal{A}_P\subseteq\mathcal{T}_\P,
\mathcal{E}_P\cap\mathcal{A}_P=\emptyset$;
naturally action terms will use data expressions as subterms.
To be able to reason about the data flow between pLTSs, we
distinguish \emph{input variables} of the form $?x$ within terms; the function
$\vars(t)$ identifies the set of variables in a term
$t\in\AlgT$, and $iv(t)$ returns its input variables.
Action algebras can encode naturally usual point-to-point message passing calculi (using 
$a(?x_1,...,?x_n)$ for inputs, $a(v_1,..,v_n)$ for outputs), but it also allows
for more general mechanisms, like gate negociation in Lotos, or broadcast
communications. 



\subsection{The (open) pNets Core Model}
\label{section:pNets}


A pLTS is a labelled transition system with variables; variables can be
manipulated, defined, or accessed inside states, actions, guards, and
assignments. Without loss of generality and to simplify the formalisation, we suppose 
here that 
variables are local to each 
state: each state has its set of variables disjoint from the others. Transmitting 
variable values from one state to the other can be done by explicit assignment. 
%Similarly, to simplify the management of variables and without loss of expressivity, we 
%suppose that transitions looping to the same state does not do assignments.
Note that we make no assumption on finiteness of the set of states nor
on finite branching of the transition relation.

We first define the set of actions a pLTS can use, let $a$
range over action labels, $\symb{op}$ are operators, and $x_i$ range over
variable names. Action terms are:\noteLH{Eric suggests to remove this: too precise. I 
think last Expression should be removed not sure about the rest -- to be discussed}
\[
\begin{array}[l]{rcl@{\quad}p{5.5cm}}
  \alpha\in\AlgA&::=&a(p_1,\ldots,p_n)&\text{action terms}\\
  p_i&::=& ?x~|~\symb{Expr}&\text{parameters (input variable or expression)}\\
  \symb{Expr}&::=& 
  \symb{Value}~|~x~|~\symb{op}(\symb{Expr}_1,..,\symb{Expr}_n)&\text{Expressions}
\end{array}
\]
The input variables in an action term are those marked with a
$\symb{?}$.
We additionally suppose that each input variable does not
appear somewhere else in the same action term:
$p_i=?x\Rightarrow\forall j\neq i.\, x\notin \vars(p_j)$

\begin{definition}[pLTS]
\label{pLTS}
A pLTS is a tuple
$\pLTS\triangleq\mylangle S,s_0, \to\myrangle$ where:
\begin{itemize}
\item[$\bullet$]
$S$ is a set of states.
\item[$\bullet$]
$s_0 \in S$ is the initial state.
%\item[$\bullet$]
 %Variables in
%$\iv(\alpha)$ are assigned by the action, other variables can be assigned
%by the additional assignments.
\item[$\bullet$] $\to \subseteq S \times L \times S$ is the transition relation and 
$L$ is the set of labels of the form

$\langle \alpha,~g,~e\rangle$,
where $\alpha \in\AlgA$ is a parameterised action, $g$ is a guard, and the variables 
$x_j\in \vars(s')$
are assigned the updates in $e$.
If 
$s \xrightarrow{\langle \alpha,~g,~e\rangle} s'\in \to $ then 
% REMOVED BECAUSE USELESS: $\iv(\alpha)\!\subseteq\! \vars(s')$, 
		$\vars(\alpha)\backslash \iv(\alpha)\!\subseteq\! \vars(s)$, 
		$\vars(g)\!\subseteq\! \vars(s)\cup\vars(\alpha)$, and
		$\vars(\codom(e))\!\subseteq\! \vars(s)\cup\vars(\alpha)\land 
		\vars(\dom(e))\!\in\!\vars(s')$. %,  and $s= s'\Rightarrow J=\emptyset$. 
		
\end{itemize}
\end{definition}
\noteLH{is dom and codom clear?}
Now we define
pNet nodes, as constructors for hierarchical behavioural structures.
A pNet has a set of sub-pNets that can be either pNets or pLTSs, and a
set of Holes, playing the role of process parameters.

A composite pNet consists of a set of sub-pNets exposing
a set of actions, each of them synchronising actions in each of
the sub-pNets. The synchronisation between global actions and
internal actions is given by  \emph{synchronisation vectors}: a
synchronisation vector synchronises one or several internal actions, and
exposes a single resulting global action.
Actions involved at the pNet level (in the synchronisation vectors) do
not need to distinguish  input 
variables. Action terms for pNets are defined as follows:
\[\begin{array}[l]{rcl@{\quad}l}
  \alpha\in \AlgAS &::=&a(Expr_1,\ldots,Expr_n)
\end{array}
\]



\begin{definition}[pNets]\label{def-pnets}
A pNet is a hierarchical structure where leaves are pLTSs and holes:\\
$\pNet\triangleq \pLTS~|~\mylangle \pNet_i^{i\in I}, J, \symb{SV}_k^{k\in 
K}\myrangle$
where
\begin{itemize}
\item[$\bullet$] $I \in \I$ is the set over which sub-pNets are indexed.
\item[$\bullet$] $\pNet_i^{i\in I}$ is the family of sub-pNets.
%  $\pNet_i^{i\in I}$ is a family of sub-pNets where $I\in\I_\P$ is the set over which 
%sub-pNets are indexed.

\item[$\bullet$] $J\!\in\!\I_\P$ is a set of indexes, called \emph{holes}.
$I$ and $J$ are \emph{disjoint}: $I\!\cap\! J=\emptyset$,  $I\!\cup\! J\neq\emptyset$
%\item[$\bullet$] $\Sort_j \subseteq \AlgAS$ is a set of action terms, denoting the 
%\emph{sort} of
%hole $j$.

\item[$\bullet$] $\symb{SV}_k^{k\in K}$ is a set of
  synchronisation vectors ($K\in\I_\P$). $\forall k\!\in\! K,
  \symb{SV}_k\!=\!\alpha_{l}^{l\in I_k \uplus J_k}\to\alpha'_k\,|\,g_k$ where
  $\alpha'_k\in \mathcal{A}_\P$, $I_k\subseteq I$, $J_k\subseteq J$,
  $\forall i\!\in\!
  I_k.\,\alpha_{i}\!\in\!\Sort(\pNet_i)$,  $\forall j\!\in\!
  J_k.\,\alpha_{j}\!\in\!\Sort_j$, and $\vars(\alpha'_k)\subseteq \bigcup_{l\in I_k\uplus 
  J_k}{\vars({\alpha_l})}$. The global action of a vector $\symb{SV}_k$ is
$\Label(\symb{SV}_k) = \alpha'_k$. $g_k $ is a guard associated to the vector 
$\vars(g_k)\subseteq \bigcup_{l\in I_k\uplus J_k}{\vars({\alpha_l})}$.


\end{itemize}
\end{definition}

The preceding definition relies on the auxiliary functions below:

\begin{definition}[Sorts, Holes, Leaves of pNets]
  \begin{itemize}
  \item The sort of a pNet is its signature, i.e. the set of actions it can
perform. In the definition of sorts, we do not need to distinguish
input variables (that specify the dataflow within LTSs), so for
computing LTS sorts, we use a substitution operator\footnote{$\subst{y_k\gets x_k}^{k\in 
K}$ is the parallel substitution 
operation.} to remove the
\emph{input marker} of variables. Formally:
\[
\begin{array}{l}
\Sortop(\mylangle S,s_0, \to\myrangle) = \{\alpha\subst{x \gets ?x| 
x\in\symb{iv}(\alpha)}|s \xrightarrow{\langle \alpha,~e_b,~(x_j\!:= {e}_j)^{j\in
    J}\rangle} s'\in \to \} \\
\Sortop(\mylangle \overline{\pNet}\!, %\pNet_i^{i\in I}, \Sort_j^{j\in J}
\overline{\pNet}\!,
\overline{\symb{SV}}\myrangle)
=\{\alpha' |\, \overline{\alpha}%\alpha_j^{j\in J_k}
\to\alpha'\in\set{\symb{SV}}\}
\end{array}
\]

\item
The set of holes of a pNet is defined inductively; the sets of holes
in a pNet node and its subnets are all disjoint:
  \[\begin{array}{l}
\Holes(\mylangle S,s_0, \to\myrangle) \!=\! \emptyset \\
\Holes(\mylangle \pNet_i^{i\in I}\!,\Sort_j^{j\in J}\!, \overline{\symb{SV}}\myrangle) 
=J\uplus{\displaystyle \bigcup_{i\in 
I}\Holes(\pNet_i)}\\
\forall i\in I.\, \Holes(\pNet_i)\cap J=\emptyset\\
\forall i_1,i_2\in I.\,i_1\neq i_2\Rightarrow  
\Holes(\pNet_{i_1})\cap\Holes(\pNet_{i_2})=\emptyset
\end{array}\]
\item
The set of leaves of a pNet is the set of all pLTSs occurring in the structure, defined 
inductively as:
\noteLH{Not very nice but at least of the right kind for the definition of composition}
\[\begin{array}{l}
\Leaves(\mylangle S,s_0, \to\myrangle) \!=\!\emptyset\\
\Leaves(\mylangle \pNet_i^{i\in I}\!,%Sort_j^{j\in J}
\overline{\Sort}\!, \overline{\symb{SV}}\myrangle) = {\displaystyle \biguplus_{i\in 
I}\Leaves(\pNet_i)\uplus\{i\mapsto \pNet_i|\pNet_i=\mylangle S,s_0, \to\myrangle\}}
\end{array}\]
\end{itemize}
\end{definition}



A pNet $Q$ is \emph{closed} if it has no hole: $\Holes(Q)=\emptyset$; else it
is said to be \emph{open}.



%****************************************************************
%****************************************************************

\section{Encoding of architectures into open pNets}
\label{secn:encoding}

%****************************************************************
%****************************************************************

\section{SMT encoding of open pNets}
\label{secn:smt}

%****************************************************************
%****************************************************************

\section{Case study}
\label{secn:case-study}

%****************************************************************
%****************************************************************

\section{Related work}
\label{secn:related}

%****************************************************************
%****************************************************************

\section{Conclusion}
\label{secn:conclusion}

%****************************************************************
%****************************************************************

\bibliographystyle{abbrv}
\bibliography{biblio.bib}

%****************************************************************
%****************************************************************
\appendix
\clearpage

\section{Proofs}

\begin{lemma}
  \label{lem:onlyone}
  Let $A = (\cC, V_A, P_A, \Gamma)$ be an architecture and denote
  by $\Gamma_\cC \bydef{=}
%
  \setdef{
    (a \cap P_\cC, \true, \noop)
  }{
    (a, g, e) \in \Gamma
  }$, with $P_\cC = \bigcup_{C \in \cC} P_C$,
%  
  the projection of $\Gamma$ onto the coordinating components of
  $A$.  Consider the architecture $A' = (\{C'\}, V_A, P_A,
  \Gamma)$, where $C' = \Gamma_\cC(\cC)$.  For any set of
  components $\cB$, satisfying the conditions of
  \defn{arch:application}, we have
  $\semopen{A(\cB)} = \semopen{A'(\cB)}$.
\end{lemma}
%
\begin{proof}
  First of all, notice that, by \defn{im},
  $V_{C'} = \bigcup_{C \in \cC} V_C$ and $P_{C'} = P_\cC$.
  The conditions of \defn{arch} are satisfied and $A'$ is indeed
  an architecture.  Furthermore, $\cB$ satisfies the conditions
  of \defn{arch:application} \wrt $A'$.  Hence, the component
  $A'(\cB)$ is well defined.

  Clearly the state spaces, initial states and interfaces of both
  components coincide.  Thus we only have to prove that so do the
  transition relations.  Let us assume that
  $\cC = C_i^{i \in I}$ and $\cB = B_j^{j \in J}$.
  We will use $q_i, q_i'$ to denote the states of
  $C_i$ and $q_j, q_j'$ to denote the states of $B_j$,
  and similarly for the valuations of variables.

  By \defn{comp:semantics}, a transition
%
  \begin{equation}
    \label{eq:lem1:trans:sem}
    (q_i, \val{}{i})^{i \in I} (q_j, \val{}{j})^{j \in J}
    \goesto{a, \val[\tilde]{}{}}
    (q_i', \val{\prime}{i})^{i \in I}
    (q_j', \val{\prime}{j})^{j \in J}
  \end{equation}
%  
  is a transition in $\semopen{A(\cB)}$ (\resp
  $\semopen{A'(\cB)}$) iff
%
  \begin{equation}
    \label{eq:lem1:trans}
    q_i^{i \in I} q_j^{j \in J}
    \goesto{a, G, E}
    (q_i')^{i \in I} (q_j')^{j \in J}
    \,,
  \end{equation}
%
  is a transition in $A(\cB)$ (\resp $A'(\cB)$) and
%
  \begin{mathpar}
    \val{}{i}^{i \in I} \val{}{j}^{j \in J}
    \models G
    \,,
    \and
    (\val{\prime}{i})^{i \in I} (\val{\prime}{j})^{j \in J}
    = \val[\tilde]{}{}[E]
    \,,
    \and
    \valdiff{\val{}{i}^{i \in I} \val{}{j}^{j \in J}}{
      \val[\tilde]{}{}} \subseteq \export(a)
    \,.   
  \end{mathpar}

  By \defn{im}, \eq{lem1:trans} is a transition in $A(\cB)$
  iff $a \neq \emptyset$, $(a, g, e) \in \IMextend{\Gamma}{P}$,
  where $P = \bigcup_{B \in \cB \cup \cC} P_B$, and
  %
  \begin{enumerate}
  \item for $i \in I$,
    $q_i \goesto{a \cap P_{C_i}, g_{C_i}, e_{C_i}} q_i'$
    is a transition in $C_i$, or
    $a \cap P_{C_i} = \emptyset$ and $q_i = q_i'$,
    $g_{C_i} = \true$ and $e_{C_i} = \noop$\,;
  \item for $j \in J$,
    $q_j \goesto{a \cap P_{B_j}, g_{B_j}, e_{B_j}} q_j'$
    is a transition in $B_j$, or
    $a \cap P_{B_j} = \emptyset$ and $q_j = q_j'$,
    $g_{B_j} = \true$ and $e_{B_j} = \noop$\,;
  \item $G = g \land \bigwedge_{i \in I} g_{C_i} \land
    \bigwedge_{j \in J} g_{B_j}$ and
    $E = e; e_{C_i}^{i \in I}, e_{B_j}^{j \in J}$.
  \end{enumerate}
  %

  Similarly, \eq{lem1:trans} is a transition in
  $A'(\cB)$ iff $a \neq \emptyset$,
  $(a, g, e) \in \IMextend{\Gamma}{P}$ and
  %
  \begin{enumerate}
  \item \label{only1:coord}
    $(q_i)^{i \in I}
    \goesto{a \cap P_{C'}, g_{C'}, e_{C'}}
    (q_i')^{i \in I}$ is a transition in $C'$,
    or $a \cap P_{C'} = \emptyset$ and $q_i = q_i'$,
    for all $i \in [1,m]$,
    $g_{C'} = \true$ and $e_{C'} = \noop$\,;
  \item for $j \in J$,
    $q_j \goesto{a \cap P_{B_j}, g_{B_j}, e_{B_j}} q_j'$
    is a transition in $B_j$, or
    $a \cap P_{B_j} = \emptyset$ and $q_j = q_j'$,
    $g_{B_j} = \true$, and $e_{B_j} = \noop$;
  \item $G = g \land g_{C'} \land
    \bigwedge_{j \in J} g_{B_j}$ and
    $E = e; e_{C'}, e_{B_j}^{j \in J}$.
%
  \breakenumistart
  Notice that, for any $i \in I$, since
  $P_{C_i} \subseteq P_{C'}$, we have
  $a \cap P_{C_i} = (a \cap P_{C'}) \cap P_{C_i}$.
  Thus, if $a \cap P_{C'} \neq \emptyset$, 
  the transition in condition~\ref{only1:coord} above is
  present in $C'$ iff
  $(a \cap P_{C'}, \true, \noop) \in \Gamma_\cC$ and
  \breakenumiend
% 
  \item for $i \in I$,
    $q_i \goesto{a \cap P_{C_i}, g_{C_i}, e_{C_i}} q_i'$
    is a transition in $C_i$, or $a \cap P_{C_i} = \emptyset$
    and $q_i = q_i'$,
    $g_{C_i} = \true$ and $e_{C_i} = \noop$,
  \item $g_{C'} = \bigwedge_{i \in I} g_{C_i}$ and
    $e_{C'} = e_{C_i}^{i \in I}$.
  \end{enumerate}

  Consider $(a,g,e) \in \IMextend{\Gamma}{P}$.  By
  \eq{im:extension}, this is equivalent to
  $(a \cap P_A, g, e) \in \Gamma$.
  Since $P_{C'} = P_\cC \subseteq P_A$, we have
  $a \cap P_{C'} = a \cap P_\cC = (a \cap P_A) \cap P_\cC$.
  Hence, this is also equivalent to
  $(a \cap P_{C'}, \true, \noop) \in \Gamma_\cC$,
  which concludes the proof.
\end{proof}

\begin{lemma}
  \label{lem:onestep}
  Let $\cB$ be a set of components; let $A_i = (\{C_i\}, V_{A_i},
  P_{A_i}, \Gamma_i)$, for $i = 1,2$, be two architectures
  applicable to $\cB$, with one coordinator each, and denote
  $P_i = P_{C_i} \cup \bigcup_{B \in \cB} P_B$.
  Finally, let
%
  $
  s_1 s_2 s
%
  \goesto{a, \tilde{\val{}{}}}
%
  s_1' s_2' s'
  $,
%
  be a transition in $\semopen{(A_1 \arcomp A_2)(\cB)}$, with
  $a \neq \emptyset$, 
  $s, s' \in \prod_{B \in \cB} S_{\semopen{B}}$
  and
  $s_i, s_i' \in S_{\semopen{C_i}}$ ($i=1,2$).
%
  Then, for $i=1,2$, either $a \cap P_i = \emptyset$ and $s_i s=
  s_i' s'$, or there exists a transition
%
  $
  s_i s
%
  \goesto{a \cap P_i, \val[\doubletilde]{}{}}
%
  s_i' s''
  $ 
%
  in $\semopen{A_i(\cB)}$, with
  $\val[\doubletilde]{}{}$ being the restriction of
  $\val[\tilde]{}{}$ to
  $V_1 = V_{C_1} \cup \bigcup_{B \in \cB} V_B$ and
  $s' \order s''$.
\end{lemma}
%
\begin{proof}
  By \defn{comp:semantics}, every semantic state consists of a
  component state and a valuation of component variables.  Thus,
  we have
%
  \[
  (q_1, \val{}{1}, q_2, \val{}{2}, q, \val{}{})
%
  \goesto{a, \tilde{\val{}{}}}
%
  (q_1', \val[\primeit]{}{1}, q_2', \val[\primeit]{}{1}, q', \val[\primeit]{}{})
  \,.
  \]
%
  By \eq{comp:semantics} and \eq{im:int}, this implies
  $(q_1, q_2, q) \goesto {a, G, E} (q_1', q_2', q')$, with
%
  $G = g \land g_1 \land g_2 \land g_b$
  and
  $E = e; (e_1, e_2, e_b)$,
  where
%    
  \begin{mathpar}
    g_b = \bigwedge_{B \in \supp{a} \cap \cB} g_B
    \,,
    \and
    e_b = e_B^{B \in \supp{a} \cap \cB}
  \end{mathpar}
%
  and such that $(a, g, e) \in \Gamma$ (see
  \eq{arch:composition}) and
%
  \begin{align}
    \label{eq:guard}
    (\val{}{1}, \val{}{2}, \val{}{}) &\models G
    \,,
    \\
    \label{eq:substitution}
    (\val[\primeit]{}{1}, \val[\primeit]{}{2}, \val[\primeit]{}{})
    &= \val[\tilde]{}{}[E]
    \,,
    \\
    \label{eq:transient}
    \valdiff{(\val{}{1}, \val{}{2}, \val{}{})}{\val[\tilde]{}{}}
    &\subseteq \export(a)
    \,.
  \end{align}
%
  If $a \cap P_1 = \emptyset$, then $\supp{a} = \{C_2\}$ and, by
  \eq{transient} and \defn{im}, $s_1 = s_1'$ and $s = s'$
  (recall, \defn{im}, that, for $(a,g,e) \in \Gamma$, we have $e
  \in \exprs{V_a}$).  Hereafter, assume $a \cap P_1 \neq
  \emptyset$.

  Denoting $P_b = \bigcup_{B \in \supp{a} \cap \cB} P_B$, we
  have, by \eq{im:int},
%
  \begin{mathpar}
    q_1 \goesto{a \cap P_{C_1}, g_1, e_1} q_1'
    \and
    \text{and}
    \and
    q \goesto{a \cap P_b, g_b, e_b} q'
    \,.
  \end{mathpar}
 
  By \eq{arch:composition}, for $i=1,2$, there exist
  $(a \cap P_{A_i}, g^i, e^i) \in \Gamma_i$,
  such that $g = g^1 \land g^2$ and $e = e^1 \land e^2$.
  By \eq{guard}, we have
  $(\val{}{1}, \val{}{}) \models g^1 \land g_1 \land g_b$.

  Denoting $\val[\doubletilde]{}{}$ the restriction of
%
  $\val[\tilde]{}{}$ to
  $V_1 = V_{C_1} \cup \bigcup_{B \in \cB} V_B$,
%
  we have, by \eq{substitution} and the monotonicity of
  expressions,
%
  $(\val[\primeit]{}{1}, \val[\primeit]{}{}) \order
  \val[\doubletilde]{}{}[e^1; (e_1, e_b)]$.  Notice that all
  variables affected by both $e^1$ and $e^2$ must necessarily
  belong to $\bigcup_{B \in \cB} V_B$.  Hence,
%
  $\val[\doubletilde]{}{}[e^1; (e_1, e_b)] =
  (\val[\primeit]{}{1}, \val[\doubleprimeit]{}{})$ with 
  $\val[\primeit]{}{} \order \val[\doubleprimeit]{}{}$.

  By \eq{comp:semantics} and \eq{im:int}, we have
  \[
  (q_1, \val{}{1}, q, \val{}{})
  \goesto{a \cap P_1, \val[\doubletilde]{}{}}
  (q_1', \val[\primeit]{}{1}, q, \val[\doubleprimeit]{}{})
  \,.
  \]
\end{proof}

\begin{lemma}
  \label{lem:stepabove}
  Consider a component $B$ and let 
%
  $
  (q_1, \val{}{1})
%
  \goesto{a, \val[\tilde]{}{}}
%
  (q_2, \val{}{2})
  $,
%
  be a transition in $\semopen{B}$.  For any valuation
  $\val[\primeit]{}{1}$, such that
  $\val{}{1} \order \val[\primeit]{}{1}$ and
  $\valdiff{\val{}{1}}{\val[\primeit]{}{1}} \subseteq \export(a)$,
  there exists a transition
%
  $
  (q_1, \val[\primeit]{}{1})
%
  \goesto{a, \val[\tilde]{}{}}
%
  (q_2, \val{}{2})
  $
%
  in $\semopen{B}$.
\end{lemma}
%
\begin{proof}
  By \eq{comp:semantics}, we have
%
  \begin{mathpar}
    q_1 \goesto{a, g, e} q_2
    \,,
    \and
    \val{}{1} \models g
    \,,
    \and
    \val{}{2} = \val[\tilde]{}{}[e]
    \,,
    \and
    \text{and}
    \and
    \valdiff{\val{}{1}}{\val[\tilde]{}{}} \subseteq \export(a)
    \,.
  \end{mathpar}

  By monotonicity of guards, we deduce
  $\val[\primeit]{}{1} \models g$.
  For any $v \in \export(a)$,
  $\val[\primeit]{}{1}(v) = \val{}{1}(v) = \val[\tilde]{}{}(v)$.
  Hence, 
  $\valdiff{\val[\primeit]{}{1}}{\val[\tilde]{}{}}
  \subseteq \export(a)$.
  By \eq{comp:semantics}, we conclude 
%
  $
  (q_1, \val[\primeit]{}{1})
%
  \goesto{a, \val[\tilde]{}{}}
%
  (q_2, \val{}{2})
  $.  
\end{proof}

\begin{proof}[Proof of \thm{combining}]
  By \lem{onlyone}, we can assume that each of the two
  architectures has only one coordinating component.  For $i =
  1,2$, we denote $\{C_i\} = \cC_i$, $P_i = P_{C_i}
  \cup\ \bigcup_{B \in \cB} P_B$ and $V_i = V_{C_i}
  \cup\ \bigcup_{B \in \cB} V_B$.
  
  The initiality of $\Phi_1 \land \Phi_2$, is trivial: both
  $\Phi_1$ and $\Phi_2$ are initial, hence $s^0 \models \Phi_1
  \land \Phi_2$.

  Consider a path
%
  \[
  s^0_1 s^0_2 s^0
%
  \goesto{a^1, \val[\tilde]{1}{}}
%
  s^1_1 s^1_2 s^1
%
  \goesto{a^2, \val[\tilde]{2}{}}
  \cdots
  \goesto{a^k, \val[\tilde]{k}{}}
%
  s^k_1 s^k_2 s^k
  \]
%
  in $\semopen{(A_1 \arcomp A_2)(\cB)}$, where
  $s^0,\dots,s^k \in \prod_{B \in \cB} S_{\semopen{B}}$ and
  $s^0_i,\dots, s^k_i \in S_{\semopen{C_i}}$, for $i=1,2$.
  We have to show that $s^k \models \Phi_1 \land \Phi_2$.

  Assuming that $a^1 \cap P_1 \neq \emptyset$, by \lem{onestep},
  there exists $s^{1\prime} \in \prod_{B \in \cB} S_{\semopen{B}}$,
  such that
%
  \[
  s^0_1 s^0
%
  \goesto{a^1 \cap P_1, \val[\doubletilde]{1}{}}
%
  s^1_1 s^{1\prime}
  \]
%
  is a transition in $\semopen{A_1(\cB)}$ with
  $\val[\doubletilde]{1}{}$ being the restriction of
  $\val[\tilde]{1}{}$ to $V_1$ and
  $s^1 \order s^{1\prime}$.
%
  By \lem{stepabove}, 
  \[
  s^1_1 s^1_2 s^{1\prime}
%
  \goesto{a^2, \val[\tilde]{2}{}}
%
  s^2_1 s^2_2 s^2
  \]
  is a transition in $\semopen{(A_1 \arcomp A_2)(\cB)}$ and,
  therefore, 
  \[
  s^1_1 s^1_2 s^{1\prime}
%
  \goesto{a^2, \val[\tilde]{2}{}}
%
  s^2_1 s^2_2 s^2
%
  \goesto{a^3, \val[\tilde]{3}{}}
  \cdots
  \goesto{a^k, \val[\tilde]{k}{}}
%
  s^k_1 s^k_2 s^k
  \]
%  
  is a path in $\semopen{(A_1 \arcomp A_2)(\cB)}$.
%
  Notice that, if the above assumption, $a^1 \cap P_1 \neq
  \emptyset$, does not hold, then $s^0_1 = s^1_1$, $s^0 = s^1$
  and we can take $s^{1\prime} = s^1$ in this latter path.

  Repeating the entire argument $k-1$ times, starting with this
  shorter path, we obtain a path
%
  \begin{equation}
    \label{eq:path-in-1}
    s^0_1 s^0
    %
    \goesto{a^1 \cap P_1, \val[\doubletilde]{1}{}}
    %
    s^1_1 s^{1\prime}
    %
    \goesto{a^2 \cap P_1, \val[\doubletilde]{2}{}}
    %
    s^2_1 s^{2\prime}
    %
    \goesto{a^3 \cap P_1, \val[\doubletilde]{3}{}}
    \cdots
    \goesto{a^k \cap P_1, \val[\doubletilde]{k}{}}
    %
    s^k_1 s^{k\prime}
  \end{equation}
%  
  with $s^i \order s^{i\prime}$, for all $i \in [1,k]$.

  From \eq{path-in-1}, we conclude that the state $s^k_1
  s^{k\prime}$ is reachable in $\semopen{A_1(\cB)}$.  Since $A_1$
  enforces $\Phi_1$ on $\cB$, this implies that $s^{k\prime}
  \models \Phi_1$.  Since $s^k \order s^{k\prime}$, we deduce, by
  \defn{property}, that $s^k \models \Phi_1$.

  Symmetrically, $s^k \models \Phi_2$, which concludes
  the proof.
\end{proof}


\end{document}
